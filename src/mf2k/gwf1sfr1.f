! Time of File Save by ERB: 4/1/2005 10:07AM
! Time of File Save by ERB: 5/3/2004 9:36AM
C     Revised DEP 10 November, 2004 and March 31, 2005
C     Revised DEP 30 April, 20 May, 28 June 2004, 5 August, 2004
C     Revised DEP Feb. and 22 March 2004
C     Last change DEP and LK 25 August 2003
C     Last change:  ERB  17 June 2003
C
C       Added subroutine February 9, 2004; dep
C-------SUBROUTINE GWF1SFR1DF
C
      SUBROUTINE GWF1SFR1DF(NLAKES,NLAKESAR,LKACC7,LCSTAG,LSLAKE,LSTGLD,
     &                      ISTRIN,IDSTRT,ISTROT,ISTGNW,LSCOUT,LSCONQ,
     &                      LSCNRN,LSCPPT,LSCNTB,LSSLIN,LSCQIN,LSCGW,
     &                      LSSIN,LSSOUT,LSCOTO)
C     VERSION  1.4:CONNECTED TO LAK3 PACKAGE AND MODFLOW-GWT-- FEB. 2004
C     ******************************************************************
C     INITIALIZE POINTER VARIABLES USED BY SFR1 TO SUPPORT LAKE3 AND
C     GAGE PACKAGES AND THE GWT PROCESS
C     ******************************************************************
C     CONNECTION TO LAKE PACKAGE
            NLAKES=0
            NLAKESAR=1
            LKACC7=1
            LCSTAG=1
            LSLAKE=1
            LSTGLD=1
            ISTRIN=1
            IDSTRT=1
            ISTROT=1
            ISTGNW=1
C     CONNECTION TO THE GWT PROCESS
           LSCOUT=1
           LSCONQ=1
           LSCNRN=1
           LSCPPT=1
           LSCNTB=1
           LSSLIN=1
           LSCQIN=1
           LSCGW=1
           LSSIN=1
           LSSOUT=1
           LSCOTO=1
      RETURN
      END
C-------SUBROUTINE GWF1SFR1ALP
C
      SUBROUTINE GWF1SFR1ALP(ISUMRX,ISUMIR,LCSTRM,ICSTRM,NSTRM,IN,IOUT,
     1                 ISTCB1,ISTCB2,NSS,CONST,MAXPTS,DLEAK,LCSEG,
     2                 ICSEG,LCOTSG,LCXSEC,LCIVAR,LCQSTG,IUNITLAK,
     3                 ISTRIN,ISTROT,LCOTFLW,LCDVFLW,I15,NSOL,
     4                 LSCOUT,LSCONQ,LSCNRN,LSCNTB,LSSLIN,LSCQIN,LSCGW,
     5                 ISTGLD,IDSTRT,LSSIN,LSSOUT,LSCOTO,LKACC7,LCSTAG,
     6                 LSLAKE,ISTGNW,LSCPPT,LCNSEG,NSFRPAR,NSEGDIM,
     7                 LCSFRQ,NSTRMAR,NSSAR)
C     VERSION 1.4:CONNECTED TO LAK3 PACKAGE AND MODFLOW-GWT-- Mar 2005
C     ******************************************************************
C     ALLOCATE ARRAY STORAGE FOR STREAMS
C     ******************************************************************
C
C     SPECIFICATIONS:
C     ------------------------------------------------------------------
      CHARACTER*200 LINE
C     ------------------------------------------------------------------
C
C1------IDENTIFY PACKAGE AND INITIALIZE NSTRM.
      WRITE(IOUT,1) IN
    1 FORMAT(1X,/1X,'SFR1 -- STREAMFLOW ROUTING PACKAGE, VERSION 1.4',
     1', 3/31/2005',/,9X,'INPUT READ FROM UNIT',I4)
C
C2------READ COMMENT RECORDS, NSTRM, NSS, NSFRPAR, NPARSEG, CONST,
C        DLEAK, ISTCB1, AND ISTCB2.
      CALL URDCOM(IN,IOUT,LINE)
      LLOC=1
      CALL URWORD(LINE,LLOC,ISTART,ISTOP,2,NSTRM,R,IOUT,IN)
      CALL URWORD(LINE,LLOC,ISTART,ISTOP,2,NSS,R,IOUT,IN)
      CALL URWORD(LINE,LLOC,ISTART,ISTOP,2,NSFRPAR,R,IOUT,IN)
      CALL URWORD(LINE,LLOC,ISTART,ISTOP,2,NPARSEG,R,IOUT,IN)
      CALL URWORD(LINE,LLOC,ISTART,ISTOP,3,I,CONST,IOUT,IN)
      CALL URWORD(LINE,LLOC,ISTART,ISTOP,3,I,DLEAK,IOUT,IN)
      CALL URWORD(LINE,LLOC,ISTART,ISTOP,2,ISTCB1,R,IOUT,IN)
      CALL URWORD(LINE,LLOC,ISTART,ISTOP,2,ISTCB2,R,IOUT,IN)
      IF(NSTRM.LT.0)NSTRM=0
      IF(NSS.LT.0)NSS=0
      IF(NSFRPAR.LE.0) THEN
         NSFRPAR=0
         NPARSEG=0
      END IF
      IF(NPARSEG.LT.0) NPARSEG=0
C
C2A-----PRINT THE INFORMATION THAT WAS READ
      WRITE(IOUT,2) NSTRM,NSS,NSFRPAR,NPARSEG,DLEAK,CONST
    2 FORMAT(//1X,'NUMBER OF STREAM NODES IS ',I6//1X,
     &'NUMBER OF STREAM',
     1' SEGMENTS IS ',I6//1X,'NUMBER OF STREAM PARAMETERS IS',I5//
     2 1X,'NUMBER OF STREAM SEGMENTS DEFINED USING PARAMETERS IS ',I6//
     3 1X,'MAXIMUM DIFFERENCE IN STREAM HEAD BETWEEN ITERATONS IS ',
     4 1PE10.2//1X,'CONSTANT FOR MANNINGS EQUATION IS ',E11.4///)
      IF(ISTCB1.GT.0) WRITE(IOUT,3) ISTCB1
    3 FORMAT(1X,'FLOW TO AND FROM GROUND WATER FOR EACH STREAM REACH ',
     1       'WILL BE SAVED ON UNIT ',I4)
      IF(ISTCB2.GT.0) WRITE(IOUT,4) ISTCB2
    4 FORMAT(1X,'STREAMFLOW OUT OF EACH REACH WILL BE SAVED ON UNIT ',
     1       I4)
C
C2B-----CHECK FOR ERRORS
      IF(NSTRM.LE.0.OR.NSS.LE.0)THEN
        WRITE(IOUT,5)
    5   FORMAT(//1X,'NO STREAM REACHES (NSTRM) AND/OR SEGMENTS (NSS)--'
     1         //,' SFR PACKAGE BEING TURNED OFF'///)
        IN=0
        NSS=0
        NSTRM=0
        RETURN
      END IF
      IF(NSFRPAR.GT.0 .AND. NPARSEG.LE.0)THEN
        WRITE(IOUT,6)
    6   FORMAT(//1X,'NO STREAM SEGMENTS DEFINED BY PARAMETERS--',
     1         'NSFRPAR GT ZERO AND NPARSEG LE ZERO'//,
     1         ' SFR PACKAGE BEING TURNED OFF'///)
        IN=0
        NSS=0
        NSTRM=0
        RETURN
      END IF
C2B------ADDED CHECK FOR DLEAK; NOVEMBER 10, 2004: dep
      IF(DLEAK.LE.0.0)THEN
        DLEAK=0.00001
        WRITE(IOUT,7)
    7   FORMAT(//1X,'*** WARNING ***   ','DLEAK IS LESS THAN ',
     1         'OR EQUAL TO ZERO',' --- ',
     2         'DLEAK ASSIGNED A VALUE OF 0.0001'///)
      END IF
      NSTRMAR=NSTRM
      NSSAR=NSS
C
C3------SET LCSTRM EQUAL TO ADDRESS OF FIRST UNUSED SPACE IN RX.
      LCSTRM=ISUMRX
C
C4------CALCULATE SPACE NEEDED FOR STRM LIST (X18).
      ISPA=18*NSTRM
      ISUMRX=ISUMRX+ISPA
C
C5------CALCULATE SPACE NEEDED FOR ISTRM LIST (X5).
      ICSTRM=ISUMIR
      ISPB=5*NSTRM
      ISUMIR=ISUMIR+ISPB
C
C6------CALCULATE SPACE NEEDED FOR SEG LIST (X17).
      NSEGDIM=NSS+NPARSEG
      LCSEG=ISUMRX
      ISPC=17*NSEGDIM
      ISUMRX=ISUMRX+ISPC
C
C7------CALCULATE SPACE NEEDED FOR ISEG, NSEGCK, AND IOTSG LISTS.
      ICSEG=ISUMIR
      ISPD=3*NSEGDIM
      ISUMIR=ISUMIR+ISPD
      LCNSEG=ISUMIR
      ISPE=NSS
      ISUMIR=ISUMIR+ISPE
      LCOTSG=ISUMIR
      ISPJ=NSEGDIM
      ISUMIR=ISUMIR+ISPJ
C
C8------CALCULATE SPACE NEEDED FOR SGOTFLW, AND DVRSFLW LISTS.
      LCOTFLW=ISUMRX
      ISPF=NSS
      ISUMRX=ISUMRX+ISPF
      LCDVFLW=ISUMRX
      ISUMRX=ISUMRX+ISPF
C
C9------CALCULATE SPACE NEEDED FOR XSEC LIST (X16).
      LCXSEC=ISUMRX
      ISPG=16*NSEGDIM
      ISUMRX=ISUMRX+ISPG
C
C10-----CALCULATE SPACE NEEDED FOR IDIVAR LIST.
      LCIVAR=ISUMIR
      ISPH=2*NSEGDIM
      ISUMIR=ISUMIR+ISPH
C
C11-----CALCULATE SPACE NEEDED FOR TABULATED DISCHARGE VERSUS FLOW
C        AND WIDTH RELATIONS.
        LCQSTG=ISUMRX
        MAXPTS=3*50
        ISPI=MAXPTS*NSEGDIM
        ISUMRX=ISUMRX+ISPI
C
      ISPRX=ISPA+ISPC+2*ISPF+ISPG+ISPI
      ISPIR=ISPB+ISPD+ISPE+ISPH+ISPJ
C
C12------CALCULATE SPACE FOR CONNECTION TO LAKE PACKAGE.
      IF (IUNITLAK.LE.0) THEN
            LKACC7=ISUMRX
            LCSTAG=ISUMRX+1
            LSLAKE=ISUMRX+2
            ISTGLD=ISUMRX+3
            ISTRIN=ISUMRX+4
            IDSTRT=ISUMRX+5
            ISTROT=ISUMRX+6
            ISTGNW=ISUMRX+7
          ISUMRX=ISUMRX+8
          ISPRX=ISPRX+8
      ELSE
C
C13------CALCULATE AMOUNT OF SPACE NEEDED FOR STRIN LIST.
          ISTRIN=ISUMRX
          ISPL=NSS
          ISUMRX=ISUMRX+ISPL
C
C14------CALCULATE AMOUNT OF SPACE NEEDED FOR STROUT LIST.
          ISTROT=ISUMRX
          ISPM=NSS
          ISUMRX=ISUMRX+ISPM
C
C15------CALCULATE AMOUNT OF SPACE NEEDED FOR DSTROT LIST.
          IDSTRT=ISUMRX
          ISPN=NSS
          ISUMRX=ISUMRX+ISPN
C
          ISPRX=ISPRX+ISPL+ISPM+ISPN
      END IF
C
C16------CALCULATE SPACE NEEDED FOR SOLUTE ROUTING.
      IF (I15.GT.0) THEN
         NSRCHS=NSTRM*NSOL
         LSCOUT=ISUMRX
         ISUMRX=ISUMRX+NSRCHS
         LSCONQ=ISUMRX
         NSEGSL=NSEGDIM*NSOL
         ISUMRX=ISUMRX+NSEGSL
         LSCNRN=ISUMRX
         ISUMRX=ISUMRX+NSEGSL
         LSCPPT=ISUMRX
         ISUMRX=ISUMRX+NSEGSL
         LSCNTB=ISUMRX
         NSSGSL=NSS*NSOL
         ISUMRX=ISUMRX+NSSGSL
         LSSLIN=ISUMRX
         ISUMRX=ISUMRX+NSOL
         LSCQIN=ISUMRX
         ISUMRX=ISUMRX+NSOL
         LSCGW=ISUMRX
         ISUMRX=ISUMRX+NSOL
         LSSIN=ISUMRX
         ISUMRX=ISUMRX+NSOL
         LSSOUT=ISUMRX
         ISUMRX=ISUMRX+NSOL
         LSCOTO=ISUMRX
         ISUMRX=ISUMRX+NSOL
         ISPRX=ISPRX+NSRCHS+(3*NSSGSL)+NSEGSL+(6*NSOL)
      ELSE
C
C17------ELSE, SET FINITE DUMMY VALUES TO ISUM.
           LSCOUT=ISUMRX
           LSCONQ=ISUMRX+1
           LSCNRN=ISUMRX+2
           LSCPPT=ISUMRX+3
           LSCNTB=ISUMRX+4
           LSSLIN=ISUMRX+5
           LSCQIN=ISUMRX+6
           LSCGW=ISUMRX+7
           LSSIN=ISUMRX+8
           LSSOUT=ISUMRX+9
           LSCOTO=ISUMRX+10
         ISUMRX=ISUMRX+11
         ISPRX=ISPRX+11
      END IF
C
C18-----ALLOCATE ADDITIONAL SPACE REQUIRED FOR FLOWS NEEDED BY SEN PROCESS
      LCSFRQ=ISUMRX
      ISUMRX=ISUMRX+5*NSTRM
C
C19-----PRINT SPACE USED BY STREAM PACKAGE.
      WRITE (IOUT,8)ISPRX
    8 FORMAT(1X,I10,' ELEMENTS IN RX ARRAY ARE USED BY SFR')
      WRITE (IOUT,9)ISPIR
    9 FORMAT(1X,I10,' ELEMENTS IN IR ARRAY ARE USED BY SFR')
C
C20-----RETURN.
      RETURN
      END
C
C-------SUBROUTINE GWF1SFR1RPP
C
      SUBROUTINE GWF1SFR1RPP(STRM,ISTRM,NSTRM,IN,IOUT,SEG,ISEG,
     1                  NSS,IDIVAR,IOTSG,SGOTFLW,DVRSFLW,
     2                  MAXPTS,XSEC,QSTAGE,I15,CONCQ,CONCRUN,
     3                  CONCPPT,NSOL,IOUTS,NSFRPAR,NSEGDIM,ITERP,
     4                  INAMLOC,IBOUND,NCOL,NROW,NLAY)
C
C
C     VERSION 1.4:CONNECTED TO LAK3 PACKAGE AND MODFLOW-GWT-- Mar. 2005
C     ******************************************************************
C     READ STREAM DATA THAT IS CONSTANT FOR ENTIRE SIMULATION:
C         REACH DATA AND PARAMETER DEFINITIONS
C
C
C     ******************************************************************
C
C     SPECIFICATIONS:
C     ------------------------------------------------------------------
      DIMENSION STRM(18,NSTRM),ISTRM(5,NSTRM),SEG(17,NSEGDIM),
     1          ISEG(3,NSEGDIM),IOTSG(NSEGDIM),
     2          IDIVAR(2,NSEGDIM),SGOTFLW(NSS),DVRSFLW(NSS),
     3          XSEC(16,NSEGDIM),QSTAGE(MAXPTS,NSEGDIM),
     4          IBOUND(NCOL,NROW,NLAY)
      DIMENSION CONCQ(NSEGDIM,NSOL),CONCRUN(NSEGDIM,NSOL),
     1          CONCPPT(NSEGDIM,NSOL)
      DIMENSION IDUM(1)
C
C     ------------------------------------------------------------------
C
C1------INITIALIZE VARIABLES AND LISTS.
      IRCH=1
      DO WHILE (IRCH.LE.NSTRM)
        II=1
        DO WHILE (II.LE.16)
          STRM(II,IRCH)=0.0
          II=II+1
        END DO
        II=1
        DO WHILE (II.LE.5)
          ISTRM(II,IRCH)=0
          II=II+1
        END DO
        IRCH=IRCH+1
      END DO
C
      KSS=1
      DO WHILE (KSS.LE.NSS)
        SGOTFLW(KSS)=0.0
        DVRSFLW(KSS)=0.0
        KSS=KSS+1
      END DO
C
      KSS=1
      DO WHILE (KSS.LE.NSEGDIM)
        ISEG(1,KSS)=0
        ISEG(2,KSS)=0
        ISEG(3,KSS)=0
        IOTSG(KSS)=0
        IDIVAR(1,KSS)=0
        IDIVAR(2,KSS)=0
        II=1
        DO WHILE (II.LE.17)
          SEG(II,KSS)=0.0
          II=II+1
        END DO
        II=1
        DO WHILE (II.LE.16)
          XSEC(II,KSS)=0.0
          II=II+1
        END DO
        II=1
        DO WHILE (II.LE.(MAXPTS))
          QSTAGE(II,KSS)=0.0
          II=II+1
        END DO
        KSS=KSS+1
      END DO
C
C2------READ AND PRINT DATA FOR EACH STREAM REACH.
      NSEG=0
      NREACH=0
      WRITE(IOUT,1)
    1 FORMAT(1X,//3X,'STREAM NETWORK DESCRIPTION: ',//
     1     3X,'LAYER    ROW    COL   SEGMENT   REACH     LENGTH',
     2     /26X,'NUMBER   NUMBER    IN CELL',/3X,50('-'))
      II=1
      DO WHILE (II.LE.NSTRM)
        READ(IN,*) KRCH,IRCH,JRCH,JSEG,IREACH,STRM(1,II)
        WRITE(IOUT,2)KRCH,IRCH,JRCH,JSEG,IREACH,STRM(1,II)
    2   FORMAT(2X,I6,2I7,I8,I9,3X,1PE11.3)
C
C3------CHECK RANGE AND ORDER FOR SEGMENTS AND REACHES.
        IF(JSEG.LE.0 .OR. JSEG.GT.NSS) THEN
          WRITE(IOUT,3)
    3     FORMAT(1X,'SEGMENT MUST BE GREATER THAN 0 AND LESS THAN NSS')
          CALL USTOP(' ')
        END IF
        IF(JSEG.NE.NSEG) THEN
           NSEG=NSEG+1
           NREACH=0
           IF(JSEG.NE.NSEG) THEN
           WRITE(IOUT,4)
    4      FORMAT(1X,'SEGMENTS MUST BE IN ORDER FROM 1 THROUGH NSS')
             CALL USTOP(' ')
           END IF
        END IF
        NREACH=NREACH+1
        IF(IREACH.NE.NREACH) THEN
           WRITE(IOUT,5)
    5      FORMAT(1X,'EACH SEGMENT MUST START WITH REACH 1, AND',/
     1            1X,'REACHES MUST BE NUMBERED CONSECUTIVELY')
          CALL USTOP(' ')
        END IF
        ISTRM(1,II)=KRCH
        ISTRM(2,II)=IRCH
        ISTRM(3,II)=JRCH
        ISTRM(4,II)=JSEG
        ISTRM(5,II)=IREACH
        SEG(1,ISTRM(4,II))=SEG(1,ISTRM(4,II))+STRM(1,II)
        II=II+1
      END DO
C
C4------CHECK TO SEE IF STREAM IS IN ACTIVE CELL. Revised 4/30/04 dep
      KKPTFLG=0
      ICHK=1
      DO WHILE (ICHK.LE.NSTRM)
        KRCK=ISTRM(1,ICHK)
        IRCK=ISTRM(2,ICHK)
        JRCK=ISTRM(3,ICHK)
        JSEGCK=ISTRM(4,ICHK)
        IREACHCK=ISTRM(5,ICHK)
        IF(IBOUND(JRCK,IRCK,KRCK).EQ.0) THEN
            KKPTFLG=KKPTFLG+1
            IF (KKPTFLG.EQ.1)THEN
              WRITE(IOUT,6)JSEGCK,IREACHCK,IBOUND(JRCK,IRCK,KRCK),
     1                     KRCK,IRCK,JRCK
    6         FORMAT(/1X,'*** WARNING *** FIRST OCCURRENCE WHERE A ',
     1             'STREAM REACH IS ASSIGNED TO AN INACTIVE CELL ',
     2             'IS SEGMENT ',I4,' REACH NO.',I4,/1X,' IBOUND ',
     3             'ARRAY VALUE IS ',I4,' AT LAYER ',I4,'; ROW ',I4,
     4             '; COLUMN ',I4,'.')
            END IF
         ELSE IF(IBOUND(JRCK,IRCK,KRCK).LT.0) THEN
             WRITE(IOUT,7)JSEGCK,IREACHCK,IBOUND(JRCK,IRCK,KRCK),
     1                    KRCK,IRCK,JRCK
    7        FORMAT(/1X,'*** WARNING *** STREAM SEGMENT ',I4,
     1             ' REACH NO. ',I4,' IS CONNECTED TO A CONSTANT ',
     2             'HEAD CELL.'/1X,'IBOUND ARRAY VALUE IS ',I4,' AT ',
     3             'LAYER ',I4, '; ROW ',I4,'; COLUMN ',I4,'.',/1X,
     4             'NO STREAM LEAKAGE WILL BE ALLOWED-- SUGGEST ',
     5             'REMOVING STREAM REACH FROM CELL OR CHANGE CELL ',
     6             'TO VARIABLE HEAD.'/)
         END IF
         ICHK=ICHK+1
      END DO
      IF(KKPTFLG.EQ.1) THEN
        WRITE(IOUT,8)
    8   FORMAT(/1X,'*** WARNING *** ONLY 1 STREAM REACH WAS ',
     1             'ASSIGNED TO A CELL WHERE THE IBOUND ARRAY ',
     2             'WAS ZERO.'/1X,'PROGRAM SEARCHES FOR UPPERMOST ',
     3             'ACTIVE CELL IN VERTICAL COLUMN,IF ALL CELLS ',
     5             'ARE INACTIVE, STREAM LEAKAGE WILL NOT BE ',
     6             'ALLOWED. '/)
      ELSE IF(KKPTFLG.GT.1) THEN
        WRITE(IOUT,9)KKPTFLG
    9   FORMAT(/1X,'*** WARNING *** A TOTAL OF ',I5,'STREAM REACHES ',
     1             'WERE ASSIGNED TO CELLS WHERE THE IBOUND ARRAY ',
     2             'WAS ZERO.'/1X,'PROGRAM SEARCHES FOR UPPERMOST ',
     3             'ACTIVE CELL IN VERTICAL COLUMN FOR ALL ',
     4             'OCCURRENCES.'/1X,'IF ALL CELLS IN A VERTICAL ',
     5             'COLUMN ARE INACTIVE, STREAM LEAKAGE WILL NOT BE ',
     6             'ALLOWED FOR ASSOCIATED STREAM REACH. '/)

      END IF
C
C5------READ PARAMETER DEFINITIONS
      IF(NSFRPAR.GT.0) THEN
        LSTSUM=NSS+1
        II=1
        DO WHILE (II.LE.NSFRPAR)
          LSTBEG=LSTSUM
          CALL UPARLSTRP(LSTSUM,NSEGDIM,IN,IOUT,IP,'SFR','SFR',ITERP,
     &                   NUMINST,INAMLOC)
          NLST=LSTSUM-LSTBEG
          IF (NUMINST.GT.1) NLST = NLST/NUMINST
C6-----ASSIGN STARTING INDEX FOR READING INSTANCES
          IF (NUMINST.EQ.0) THEN
            IB=0
          ELSE
            IB=1
          END IF
C7-------READ LIST(S) OF CELLS, PRECEDED BY INSTANCE NAME IF NUMINST>0
C        REVISED ACCORDING TO COMMENTS BY GIL BARTH, SEPT. 15, 2004 erb
          LB=LSTBEG
          I=IB
          DO WHILE (I.LE.NUMINST)
            IF (I.GT.0) THEN
              CALL UINSRP(I,IN,IOUT,IP,ITERP)
            END IF
            ICHK=0
            CALL SGWF1SFR1RDSEG(NLST,LB,IN,IOUT,SEG,ISEG,IDIVAR,
     1                  IOTSG,MAXPTS,XSEC,QSTAGE,I15,CONCQ,CONCRUN,
     2                  CONCPPT,NSOL,NSEGDIM,IDUM,1,ICHK,NSS)
            CALL SGWF1SFR1PRSEG(NLST,LB,IOUT,SEG,ISEG,IDIVAR,
     1                  IOTSG,MAXPTS,XSEC,QSTAGE,I15,CONCQ,CONCRUN,
     2                  CONCPPT,NSOL,NSEGDIM,IOUTS)
            LB=LB+NLST
            I=I+1
          END DO
          II=II+1
        END DO
      END IF
C     END OF CHANGE. erb
      WRITE (IOUT,15)
   15 FORMAT(//)
C
C8------RETURN
      RETURN
      END
C
C-------SUBROUTINE GWF1SFR1RPS
C
      SUBROUTINE GWF1SFR1RPS(STRM,ISTRM,KKPER,NSTRM,IN,IOUT,SEG,ISEG,
     1                  NSEGCK,NSS,IDIVAR,IOTSG,MAXPTS,IPTFLG,XSEC,
     2                  QSTAGE,I15,CONCQ,CONCRUN,CONCPPT,NSOL,IOUTS,
     3                  NSFRPAR,NSEGDIM)
C
C
C     VERSION 1.4:CONNECTED TO LAK3 PACKAGE AND MODFLOW-GWT-- Mar. 2005
C     ******************************************************************
C     READ STREAM DATA FOR STRESS PERIOD
C
C
C     ******************************************************************
C
C     SPECIFICATIONS:
C     ------------------------------------------------------------------
      INCLUDE 'param.inc'
      DIMENSION STRM(18,NSTRM),ISTRM(5,NSTRM),SEG(17,NSEGDIM),
     1          NSEGCK(NSS),ISEG(3,NSEGDIM),IOTSG(NSEGDIM),
     2          IDIVAR(2,NSEGDIM),XSEC(16,NSEGDIM),
     3          QSTAGE(MAXPTS,NSEGDIM)
      DIMENSION CONCQ(NSEGDIM,NSOL),CONCRUN(NSEGDIM,NSOL),
     1          CONCPPT(NSEGDIM,NSOL)
C
C     ------------------------------------------------------------------
C
C
C1------READ ITMP FLAG TO REUSE NON-PARAMETER DATA, 2 PRINTING FLAGS,
C1------AND THE NUMBER OF PARAMETERS BEING USED IN CURRENT STRESS PERIOD.
      IF(NSFRPAR.EQ.0) THEN
        READ(IN,*) ITMP,IRDFLG,IPTFLG
        NP=0
      ELSE
        READ(IN,*) ITMP,IRDFLG,IPTFLG,NP
      END IF
C
C2------CHECK FOR TOO MANY SEGMENTS.
      IF(ITMP.GT.NSS) THEN
        WRITE(IOUT,6)
    6   FORMAT(/1X,'CANNOT SPECIFY MORE THAN NSS STREAM SEGMENTS')
        CALL USTOP(' ')
      END IF
C
C3------REUSE NON-PARAMETER DATA FROM LAST STRESS PERIOD IF ITMP<0
      IF(ITMP.LT.0) THEN
        IF(KKPER.EQ.1)THEN
          WRITE(IOUT,4)
    4     FORMAT(//1X,' ***  STREAM SEGMENTS MUST BE DEFINED FOR ',
     1             'FIRST STRESS PERIOD; CODE STOPPING ***')
          CALL USTOP(' ')
        ELSE IF(NSFRPAR.EQ.0) THEN
          WRITE(IOUT,5)
    5     FORMAT(/1X,
     1     'REUSING STREAM SEGMENT DATA FROM LAST STRESS PERIOD')
          RETURN
        ELSE
C3A----INITIALIZE NSEGCK TO 0 FOR SEGMENTS THAT ARE DEFINED BY CURRENTLY
C3A----USED PARAMETERS.
          WRITE(IOUT,5)
          IP=1
          DO WHILE (IP.LE.MXPAR)
            IF (PARTYP(IP).EQ.'SFR' .AND. IACTIVE(IP).GT.0) THEN
              IC=IPLOC(1,IP)
              DO WHILE (IC.LE.IPLOC(2,IP))
                NSEGCK(ISEG(3,IC))=0
                IC=IC+1
              END DO
            END IF
            IP=IP+1
          END DO
        END IF
      ELSE
C
C4------NOT REUSING DATA -- INITIALIZE NSEGCK LIST TO ZERO FOR ALL
C4------SEGMENTS.
        KSS=1
        DO WHILE (KSS.LE.NSS)
          NSEGCK(KSS)=0
          KSS=KSS+1
        END DO
      END IF
C
C5------READ NON-PARAMETER STREAM SEGMENT DATA.
      IF(ITMP.GT.0) THEN
          LSTBEG=1
          ICHK=1
          CALL SGWF1SFR1RDSEG(ITMP,LSTBEG,IN,IOUT,SEG,ISEG,IDIVAR,
     1                  IOTSG,MAXPTS,XSEC,QSTAGE,I15,CONCQ,CONCRUN,
     2                  CONCPPT,NSOL,NSEGDIM,NSEGCK,NSS,ICHK,NSS)
      END IF
C
C6------DEACTIVATE ANY PREVIOUSLY USED STREAM PARAMETERS, AND ACTIVATE
C6------PARAMETERS BEING USED IN CURRENT STRESS PERIOD.
      CALL PRESET('SFR')
      JJ=1
      DO WHILE (JJ.LE.NP)
        CALL SGWF1SFR1PARMOV(IN,IOUT,SEG,ISEG,IDIVAR,
     1          IOTSG,MAXPTS,XSEC,QSTAGE,I15,CONCQ,CONCRUN,
     2          CONCPPT,NSOL,NSEGDIM,NSEGCK,NSS)
        JJ=JJ+1
      END DO
C
C7------CHECK FOR ERRORS IN SEGMENT DATA.
      NSEG=1
      DO WHILE (NSEG.LE.NSS)
        IF (NSEGCK(NSEG).LE.0.AND.KKPER.EQ.1) THEN
          WRITE (IOUT,8) NSEG
    8     FORMAT (/5X,'*** WARNING ***  INPUT DATA FOR SEGMENT',
     1       I6,' WERE NOT DEFINED')
        ELSE IF (NSEGCK(NSEG).GT.1) THEN
          WRITE (IOUT,9) NSEG,NSEGCK(NSEG)
    9     FORMAT (/5X,'*** ERROR ***  DATA FOR SEGMENT',I6,
     1       ' WERE DEFINED ',I2,' TIMES (INSTEAD OF ONCE)')
          CALL USTOP(' ')
        END IF
C7B----REVISED TO CHECK FOR ZERO SLOPE; NOVEMBER 10, 2004: dep
        IF (SEG(8,NSEG).LE.SEG(13,NSEG)) THEN
          WRITE (IOUT,10) NSEG
   10     FORMAT (/5X,'*** WARNING *** UPSTREAM ELEVATION IS ',
     1       'EQUAL TO OR LOWER THAN DOWNSTREAM ELEVATION FOR ',
     2       'SEGMENT No. ',I6)
          IF(ISEG(1,NSEG).EQ.1.OR.ISEG(1,NSEG).EQ.2) THEN
            WRITE (IOUT,1010) NSEG,ISEG(1,NSEG)
 1010       FORMAT (/5X,'*** ERROR ***  ',
     1         'SLOPE IS ZERO OR NEGATIVE FOR SEGMENT No.',
     2         I5,'   SLOPE MUST BE POSITIVE WHEN ICALC IS',
     3         I3)
            CALL USTOP(' ')
          END IF
        END IF
        IF (IDIVAR(2,NSEG).GT.0) THEN
          WRITE (IOUT,11) NSEG
   11     FORMAT (/5X,'*** WARNING *** IPRIOR > 0 FOR NSEG = ',I6,
     1               /10X,'THIS OPTION NOT YET AVAILABLE; CODE WILL '
     2           ,   'ASSUME IPRIOR = 0'/)
          IDIVAR(2,NSEG)=0
        ELSE IF (IDIVAR(2,NSEG).LT.-3) THEN
          WRITE (IOUT,12) NSEG
   12     FORMAT (/5X,'*** WARNING *** IPRIOR < -3 FOR NSEG = ',
     1           I6,/10X,'THIS VALUE IS OUT OF RANGE; CODE WILL ',
     2           'ASSUME IPRIOR = 0'/)
          IDIVAR(2,NSEG)=0
        ELSE IF (IDIVAR(2,NSEG).EQ.-2) THEN
          IF (SEG(2,NSEG).LT.0.0.OR.SEG(2,NSEG).GT.1.0) THEN
             WRITE (IOUT,13) NSEG
   13        FORMAT (/5X,'*** WARNING *** IPRIOR = -2 FOR NSEG = ',
     1                  I6,' & FLOW VALUE IS OUT OF RANGE (.0 - 1.);',
     2                  /10X,'ASSUME NO DIVERSION OF FLOW'/)
             SEG(2,NSEG)=0.0
          END IF
        END IF
        NSEG=NSEG+1
       END DO
C
C8------PLACE STREAM SEGMENT IDENTITY NUMBERS IN ISEG ARRAY.
C       5 ASSIGNED TO SEGMENTS NOT RECEIVING TRIBUTARY FLOW.
C       6 ASSINGED TO SEGMENTS THAT DIVERT FLOW.
C       7 ASSIGNED TO SEGMENTS RECEIVING TRIBUTARY FLOW.
      K5=0
      K6=0
      K7=0
      NSEG=1
      DO WHILE (NSEG.LE.NSS)
C
C9------IDENTIFY SEGMENTS THAT DIVERT FLOW.
        IF (IDIVAR(1,NSEG).NE.0) THEN
          ISEG(3,NSEG)=6
          K6=K6+1
C
C10-----IDENTIFY SEGMENTS THAT DO NOT DIVERT FLOW.
        ELSE
          JJ=0
C
C11-----IDENTIFY SEGMENTS THAT RECEIVE TRIBUTARY FLOW.
          II=1
          DO WHILE (II.LE.NSS)
            IF(IOTSG(II).EQ.NSEG) JJ=1
            II=II+1
          END DO
C
C12-----IDENTIFY SEGMENTS THAT DO NOT RECEIVE TRIBUTARY FLOW.
          IF (JJ.EQ.0) THEN
            ISEG(3,NSEG)=5
            K5=K5+1
          ELSE
            ISEG(3,NSEG)=7
            K7=K7+1
              IF (JJ.NE.1) WRITE(IOUT,14) NSEG,JJ
   14           FORMAT (//5X,'*** WARNING *** ERROR WHILE ',
     1             'CLASSIFYING SEGMENTS:   NSEG =',I6,4X,'JJ =',I6//)
          END IF
        END IF
        NSEG=NSEG+1
      END DO
C
C13-----TALLY DIFFERENT STREAM SEGMENT TYPES.
      KTOT=K5+K6+K7
      WRITE (IOUT,15) K5,K6,K7
   15 FORMAT(///1X,'CLASSIFICATION & COUNT OF STREAM SEGMENTS BASED',
     1     ' ON SOURCE OF INFLOW:'//16X,'HEADWATER     DIVERSION     ',
     2     'RECEIVES TRIBUTARY FLOW'/16X,'---------     ---------    ',
     3     ' -----------------------'/16X,I6,9X,I6,10X,I6/)
C
C14-----PRINT WARNING IF TALLIED SEGMENTS LESS THAN NSS.
      IF (KTOT.NE.NSS) THEN
        WRITE (IOUT,16) KTOT,NSS
   16   FORMAT (/5X,'*** WARNING ***  INTERNAL ERROR SUMMING ',
     1         'TYPES OF STREAM SEGMENTS:  NSEG =',I6,5X,'JJ =',I6//)
        CALL USTOP(' ')
      END IF
C
C15-----PRINT INPUT DATA IF IRDFLG IS ZERO.
      IF(IRDFLG.LE.0)
     1     CALL SGWF1SFR1PRSEG(NSS,1,IOUT,SEG,ISEG,IDIVAR,
     2                  IOTSG,MAXPTS,XSEC,QSTAGE,I15,CONCQ,CONCRUN,
     3                  CONCPPT,NSOL,NSEGDIM,IOUTS)
C
C16----COMPUTE STREAM REACH VARIABLES.
      NSEG=1
      IRCH=1
      DO WHILE (NSEG.LE.NSS)
        ICALC=ISEG(1,NSEG)
        SEGLEN=SEG(1,NSEG)
        RUNOFF=SEG(3,NSEG)
        ETSW=SEG(4,NSEG)
        PPTSW=SEG(5,NSEG)
        HCSLPE=(SEG(6,NSEG)-SEG(11,NSEG))/SEGLEN
        THKSLPE=(SEG(7,NSEG)-SEG(12,NSEG))/SEGLEN
        ELSLPE=(SEG(8,NSEG)-SEG(13,NSEG))/SEGLEN
        WDSLPE=(SEG(9,NSEG)-SEG(14,NSEG))/SEGLEN
        DPSLPE=(SEG(10,NSEG)-SEG(15,NSEG))/SEGLEN
        SUMLEN=0.D0
        DO WHILE(IRCH.LE.NSTRM)
          IF(NSEG.NE.ISTRM(4,IRCH)) GO TO 100
          RCHLEN=STRM(1,IRCH)
          DIST=SUMLEN+(0.5*RCHLEN)
          AVHC=SEG(6,NSEG)-(HCSLPE*DIST)
          AVTHK=SEG(7,NSEG)-(THKSLPE*DIST)
          AVDPTH=SEG(10,NSEG)-(DPSLPE*DIST)
          STRM(2,IRCH)=ELSLPE
          STRM(3,IRCH)=SEG(8,NSEG)-(ELSLPE*DIST)
          STRM(4,IRCH)=STRM(3,IRCH)-AVTHK
          STRM(6,IRCH)=AVHC
          STRM(8,IRCH)=AVTHK
          STRM(12,IRCH)=RUNOFF*(RCHLEN/SEGLEN)
          IF(ICALC.EQ.0) THEN
            STRM(5,IRCH)=SEG(9,NSEG)-(WDSLPE*DIST)
            STRM(7,IRCH)=AVDPTH
            STRM(13,IRCH)=ETSW*RCHLEN*STRM(5,IRCH)
            STRM(14,IRCH)=PPTSW*RCHLEN*STRM(5,IRCH)
            STRM(15,IRCH)=AVDPTH+STRM(3,IRCH)
            STRM(16,IRCH)=(AVHC*STRM(5,IRCH)*RCHLEN)/AVTHK
          ELSE IF (ICALC.EQ.1) THEN
            STRM(5,IRCH)=SEG(9,NSEG)-(WDSLPE*DIST)
            STRM(7,IRCH)=1.0
            STRM(13,IRCH)=ETSW*RCHLEN*STRM(5,IRCH)
            STRM(14,IRCH)=PPTSW*RCHLEN*STRM(5,IRCH)
            STRM(15,IRCH)=STRM(3,IRCH)
            STRM(16,IRCH)=(AVHC*STRM(5,IRCH)*RCHLEN)/AVTHK
          ELSE IF (ICALC.GE.2.AND.ICALC.LE.4) THEN
            STRM(5,IRCH)=1.0
            STRM(7,IRCH)=1.0
            STRM(13,IRCH)=ETSW*RCHLEN
            STRM(14,IRCH)=PPTSW*RCHLEN
            STRM(15,IRCH)=STRM(3,IRCH)
            STRM(16,IRCH)=(STRM(5,IRCH)*STRM(1,IRCH)*
     1                   STRM(6,IRCH))/STRM(8,IRCH)
          END IF
          SUMLEN=SUMLEN+RCHLEN
          IRCH=IRCH+1
        END DO
100     NSEG=NSEG+1
      END DO
C
C17------CHECK VALUES IN STREAM CROSS SECTION LIST (XSEC).
      NSEG=1
      DO WHILE (NSEG.LE.NSS)
        ICALC=ISEG(1,NSEG)
        IF(ICALC.EQ.2) THEN
          JJ=1
          IF(XSEC(JJ,NSEG).NE.0.0) THEN
            WRITE(IOUT,37)NSEG
   37       FORMAT(1X,/1X,'*** ERROR *** EIGHT POINT CROSS SECTION ',
     1            'FOR STREAM SEGMENT ',I6,' DOES NOT BEGIN WITH ',
     2            'ZERO FOR FIRST VALUE -- PROGRAM STOPPING')
            CALL USTOP(' ')
          END IF
          DO WHILE (JJ.LE.8)
            IF(XSEC(JJ,NSEG).LT.0.0) THEN
              WRITE(IOUT,38)NSEG,JJ,XSEC(JJ,NSEG)
   38         FORMAT(1X,/1X,'*** ERROR *** STREAM SEGMENT ',I6,
     1             ' HAS A NEGATIVE X DISTANCE FOR POINT ',
     2              I5,' INPUT VALUE IS ',E10.3,/1X,
     3             'ALL VALUES MUST BE POSITIVE WITH ',
     4             'FIRST X VALUE STARTING AT EXTREME LEFT ',
     5             'EDGE OF SECTION LOOKING DOWNSTREAM ',
     6             'PROGRAM STOPPING')
              CALL USTOP(' ')
            END IF
            KK=JJ+8
            IF(XSEC(KK,NSEG).LT.0.0) THEN
              WRITE(IOUT,39)NSEG,KK,XSEC(KK,NSEG)
   39         FORMAT(1X,/1X,'*** ERROR *** STREAM SEGMENT ',I6,
     1               ' HAS A NEGATIVE Z DISTANCE FOR POINT ',
     2               I5,' INPUT VALUE IS ',E10.3,/1X,
     3               'ALL VALUES MUST BE POSITIVE RELATIVE ',
     4               'TO STREAMBED ELEVATION ')
              CALL USTOP(' ')
            END IF
            JJ=JJ+1
          END DO
        END IF
        NSEG=NSEG+1
      END DO
C
C18------CHECK ROUGHNESS COEFFICIENTS WHEN ICALC = 1 OR 2.
      NSEG=1
      DO WHILE (NSEG.LE.NSS)
        ICALC=ISEG(1,NSEG)
        IF (ICALC.EQ.1) THEN
          ROUGH=SEG(16,NSEG)
          IF (ROUGH.LE.0.0) THEN
            WRITE(IOUT,40)ROUGH
   40       FORMAT('*** ERROR *** ROUGHNESS COEFFICIENT WHEN ',
     1           'ICALC = 1 IS LESS THAN OR EQUAL TO ZERO',//1X,
     2           'VALUE IS ',1PE10.3,//1X,'PROGRAM STOPPING')
            CALL USTOP(' ')
          END IF
        ELSE IF (ICALC.EQ.2) THEN
          ROUGHCH=SEG(16,NSEG)
          ROUGHBNK=SEG(17,NSEG)
          IF (ROUGHCH.LE.0.0) THEN
            WRITE(IOUT,41) ROUGHCH
   41       FORMAT('*** ERROR *** ROUGHNESS COEFFICIENT FOR CHANNEL ',
     1           'WHEN ICALC =2 IS LESS THAN OR EQUAL TO ZERO',
     2           //1X,'VALUE IS ',1PE10.3,//1X,'PROGRAM STOPPING')
            CALL USTOP(' ')
          ELSE IF (ROUGHBNK.LE.0.0) THEN
            WRITE(IOUT,42) ROUGHBNK
   42       FORMAT('*** ERROR *** ROUGHNESS COEFFICIENT FOR BANK ',
     1           'WHEN ICALC =2 IS LESS THAN OR EQUAL TO ZERO',
     2           //1X,'VALUE IS ',1PE10.3,//1X,'PROGRAM STOPPING')
            CALL USTOP(' ')
          END IF
        END IF
        NSEG=NSEG+1
      END DO
C
C19------CHECK VALUES IN TABLE OF FLOW VERSUS DEPTH AND WIDTH
C          WHEN ICALC = 4. Revised 4/30/2004 dep
      NSEG=1
      DO WHILE (NSEG.LE.NSS)
        ICALC=ISEG(1,NSEG)
        IF(ICALC.EQ.4)NSTRPTS=ISEG(2,NSEG)
        IF(ICALC.EQ.4) THEN
          FLWLW=QSTAGE(1,NSEG)
          IF(FLWLW.LE.0.0) THEN
            WRITE(IOUT,43) NSEG
   43       FORMAT(/1X,'*** WARNING *** FIRST FLOW VALUE IN TABLE OF ',
     1             'FLOW VERSUS DEPTH AND WIDTH IS LESS THAN OR ',
     2             'EQUAL TO ZERO FOR SEGMENT NUMBER ',I6,/1X,'VALUE ',
     3             'SHOULD BE GREATER THAN ZERO-- IT HAS BEEN ',
     4             'RESET TO 0.1 BUT MAY CAUSE INSTABILITY')
            QSTAGE(1,NSEG)=0.1
          END IF
          DPTHLW=QSTAGE(1+NSTRPTS,NSEG)
          IF(DPTHLW.LE.0.0) THEN
            WRITE(IOUT,44) NSEG
   44       FORMAT(/1X,'*** WARNING *** FIRST DEPTH VALUE IN TABLE OF ',
     1             'FLOW VERSUS DEPTH AND WIDTH IS LESS THAN OR EQUAL ',
     2             'TO ZERO FOR SEGMENT NUMBER ',I6,/1X,'VALUE ',
     3             'SHOULD BE GREATER THAN ZERO-- IT HAS BEEN ',
     4             'RESET TO 0.01 BUT MAY CAUSE INSTABILITY')
            QSTAGE(1+NSTRPTS,NSEG)=0.01
          END IF
          WDTHLW=QSTAGE(1+2*NSTRPTS,NSEG)
          IF(WDTHLW.LE.0.0) THEN
            WRITE(IOUT,46) NSEG
   46       FORMAT(/1X,'*** WARNING *** FIRST WIDTH VALUE IN TABLE OF ',
     1             'FLOW VERSUS DEPTH AND WIDTH IS LESS THAN OR EQUAL ',
     2             'TO ZERO FOR SEGMENT NUMBER ',I6,/1X,'VALUE ',
     3             'SHOULD BE GREATER THAN ZERO-- IT HAS BEEN ',
     4             'RESET TO 1.0 BUT MAY CAUSE INSTABILITY')
            QSTAGE(1+2*NSTRPTS,NSEG)=1.0
          END IF
          IPT=2
          DO WHILE(IPT.LE.NSTRPTS)
            FLW1=QSTAGE(IPT-1,NSEG)
            FLW2=QSTAGE(IPT,NSEG)
            DPTH1=QSTAGE((IPT-1)+NSTRPTS,NSEG)
            DPTH2=QSTAGE(IPT+NSTRPTS,NSEG)
            WDTH1=QSTAGE((IPT-1)+(2*NSTRPTS),NSEG)
            WDTH2=QSTAGE(IPT+(2*NSTRPTS),NSEG)
            IF(FLW2.LE.FLW1) THEN
              WRITE(IOUT,47) NSEG,FLW2,IPT
   47         FORMAT(/1X,'*** ERROR *** SEGMENT NUMBER ',I6,' HAS ',
     1                  'SPECIFIED FLOW VALUE OF ',1PE10.2,' IN ',
     2                  'LOCATION ',I5,' THAT IS LESS THAN OR EQUAL ',
     3                  'TO PRECEDING VALUE',/1X,'FLOW VALUES MUST ',
     4                  'BE GREATER THAN PRECEDING VALUE IN TABLE--',
     5                  ' PROGRAM STOPPING')
              CALL USTOP(' ')
            END IF
            IF(DPTH2.LE.DPTH1) THEN
              WRITE(IOUT,48) NSEG,DPTH2,IPT
   48         FORMAT(/1X,'*** ERROR *** SEGMENT NUMBER ',I6,' HAS ',
     1                  'SPECIFIED DEPTH VALUE OF ',1PE10.2,' IN ',
     2                  'LOCATION ',I5,' THAT IS LESS THAN OR EQUAL ',
     3                  'TO PRECEDING VALUE',/1X,'DEPTH VALUES MUST ',
     4                  'BE GREATER THAN PRECEDING VALUE IN TABLE--',
     5                  ' PROGRAM STOPPING')
              CALL USTOP(' ')
            END IF
            IF(WDTH2.LT.WDTH1) THEN
              WRITE(IOUT,49) NSEG,WDTH2,IPT
   49         FORMAT(/1X,'*** WARNING *** SEGMENT NUMBER ',I6,' HAS ',
     1                 'SPECIFIED WIDTH VALUE OF ',1PE10.2,' IN ',
     2                 'LOCATION ',I5,' THAT IS LESS THAN PRECEDING ',
     3                 'VALUE',/1X,'FOR MOST CHANNELS, WIDTH NORMALLY',
     4                 ' INCREASES WITH FLOW')
            END IF
            IPT=IPT+1
          END DO
        END IF
        NSEG=NSEG+1
      END DO
C
      WRITE (IOUT,3)
    3 FORMAT(//)
C
C20------RETURN.
      RETURN
      END
C
C--------SUBROUTINE GWF1SFR1FM
C
      SUBROUTINE GWF1SFR1FM(STRM,ISTRM,HNEW,HCOF,RHS,IBOUND,NSTRM,NCOL,
     1                  NROW,NLAY,IOUT,NSS,SEG,ISEG,IOTSG,XSEC,IDIVAR,
     2                  QSTAGE,CONST,MAXPTS,DLEAK,SGOTFLW,DVRSFLW,
     3                  NLAKESAR,STGOLD,STRIN,STROUT,STGNEW,THETA,
     4                  VOL,ISS,DSTROT,SFRQ,IUNITLAK,KKITER,KKPER,KKSTP)
C
C     VERSION 1.4:CONNECTED TO LAK3 PACKAGE AND MODFLOW-GWT-- Mar. 2005
C
C     *****************************************************************
C     ADD STREAM TERMS TO RHS AND HCOF IF FLOW OCCURS IN MODEL CELL
C     *****************************************************************
C
C     SPECIFICATIONS:
C     -----------------------------------------------------------------
C
      DOUBLE PRECISION CSTR,CSTR1,CSTR2,DBLEAK,DLET1,DLET2,DLFH,
     1            DLH,DLPP1,DLPP2,DLWP1,DLWP2,DEPTH,DEPTHX,DEPTHP,
     2            DEPTHA,DEPTHB,DEPTHC,DEPTHD,DEPTH1,DEPTH2,
     3            DLKSTR,DLKSTR1,DLKSTR2,DEPS,ET1,ET2,
     4            FHSTR1,FHSTR2,FLOBOT,FLOBOT1,FLOBOT2,FLOWC,FLOWIN,
     5            FLOWOT,FLWDLK1,FLWDLK2,FLWMDPTA,FLWMDPTB,FLWMDPTC,
     6            FLWMDPTD,FLWMDPT1,FLWMDPT2,FLWMPT,HNEW,H,
     7            HSTR,PP1,PP2,SBOT,SLOPE,STRLEAK,STRTOP,TRBFLW,
     8            UPFLW,WDTHLK1,WDTHLK2,WETPERM,WETPERMA,WETPERMB,
     9            WETPERMC,WETPERMD,WETPERM1,WETPERM2,WETPERMP,WETPERMX,
     *            WIDTH,WIDTHA,WIDTHB,WIDTHC,WIDTHD,WIDTH1,WIDTH2,
     *            WIDTHP,WIDTHX,BWDTH,CDPTH,FDPTH,AWDTH,F1,F2,
     *            FP,ENPT1,ENPT2,FLWEN1,FLWEN2,FLWP,FLOBOTP,
     *            FLOBOTX,FLOBOTOLD,FLWPETP,FLWPET1,FLWPET2,FLWX,
     *            FLWMPT2,FLWEST,ERR,FPOLD,DLHOLD,PRECIP,ETSTR

C     ADD FOR SAVING Qs NEEDED BY SEN PROCESS WHEN SFR IS ACTIVE
C       SFRQ(1,n) = FLOW (AT REACH MIDPOINT)
C       SFRQ(2,n) = FLOWC
C       SFRQ(3,n) = FLOBOT
C       SFRQ(4,n) = WIDTH
C       SFRQ(5,n) = FLOWIN
      REAL SFRQ(5,NSTRM)

C     -----------------------------------------------------------------
      DIMENSION STRM(18,NSTRM),ISTRM(5,NSTRM),
     1          HNEW(NCOL,NROW,NLAY),HCOF(NCOL,NROW,NLAY),
     2          RHS(NCOL,NROW,NLAY),IBOUND(NCOL,NROW,NLAY),
     3          SEG(17,NSS),ISEG(3,NSS),IOTSG(NSS),XSEC(16,NSS),
     4          IDIVAR(2,NSS),QSTAGE(MAXPTS,NSS),SGOTFLW(NSS),
     5          DVRSFLW(NSS),STGOLD(NLAKESAR),STRIN(NSS),
     6          STROUT(NSS),STGNEW(NLAKESAR),DSTROT(NSS),VOL(NLAKESAR)
C     -----------------------------------------------------------------
C
C1-----IF NSTRM<=0 THERE ARE NO STREAMS. RETURN.
      IF(NSTRM.LE.0)RETURN
C
C2-----THERE ARE STREAMS.  INITIALIZE SEGMENT INFLOWS AND OUTFLOWS
C       TO ZERO FOR LAKE PACKAGE.
!CERB add more initializations
!      ETSTR=0.0D0
!      PRECIP=0.0D0
!      ITOT=0
!CERB END OF CHANGE
      ITSTR=0
      IPRVSG=-1
      I=1
      DO WHILE (I.LE.NSS)
         IF(IUNITLAK.GT.0) THEN
           STRIN(I)=0.0
           STROUT(I)=0.0
           DSTROT(I)=0.0
         END IF
         I=I+1
      END DO
C
C3-----DETERMINE LAYER, ROW, COLUMN OF EACH REACH.
      L=1
      DO WHILE(L.LE.NSTRM)
        LL=L-1
        IL=ISTRM(1,L)
        IR=ISTRM(2,L)
        IC=ISTRM(3,L)
C4-----DETERMINE STREAM SEGMENT AND REACH NUMBER.
        ISTSG=ISTRM(4,L)
        NREACH=ISTRM(5,L)
        ICALC=ISEG(1,ISTSG)
        IF(ICALC.EQ.1.OR.ICALC.EQ.2)SLOPE=STRM(2,L)
C
C5-----SET FLOWIN EQUAL TO STREAM SEGMENT INFLOW IF FIRST REACH.
      IF(NREACH.EQ.1) THEN
          IF(ISEG(3,ISTSG).EQ.5) FLOWIN=SEG(2,ISTSG)
C
C6-----STORE OUTFLOW FROM PREVIOUS SEGMENT IN SGOTFLW LIST AND IN
C         STRIN FOR LAKE PACKAGE.
          IF(ISTSG.GT.1)THEN
            IPRVSG = ISTRM(4,LL)
            SGOTFLW(IPRVSG)=STRM(9,LL)
            IF(IUNITLAK.GT.0)STRIN(IPRVSG)=STRM(9,LL)
          END IF
C
C7-----COMPUTE INFLOW OF A STREAM SEGMENT EMANATING FROM A LAKE.
          IF((IUNITLAK.GT.0).AND.(IDIVAR(1,ISTSG).LT.0)) THEN
              LK=IABS(IDIVAR(1,ISTSG))
              STGON=(1.0-THETA)*STGOLD(LK)+
     1              THETA*STGNEW(LK)
              DLKSTR=STGON-SEG(8,ISTSG)
C8-----CHECK IF LAKE OUTFLOW IS SPECIFIED AT A FIXED RATE.
              IF (SEG(2,ISTSG).GT.0.0.AND.VOL(LK).GT.0.0) THEN
                 FLOWIN=SEG(2,ISTSG)
                 STROUT(ISTSG)=FLOWIN
                 IF(ISS.NE.0)DSTROT(ISTSG)=0.
              ELSE IF (SEG(2,ISTSG).LT.0.0) THEN
                 WRITE (IOUT,1) ISTSG
    1            FORMAT (/5X,'*** WARNING *** NEGATIVE LAKE OUTFLOW ',
     1                'NOT ALLOWED; SEG = ',I6,
     2                /10X,'CODE WILL ASSUME FLOW = 0.0'/)
                 SEG(2,ISTSG)=0.0
                 FLOWIN=SEG(2,ISTSG)
                 STROUT(ISTSG)=FLOWIN
                 IF(ISS.NE.0)DSTROT(ISTSG)=0.
              ELSE
C
C9-----SPECIFIED FLOW FROM LAKE IS ZERO AND ICALC IS ZERO.
                IF (ICALC.EQ.0) THEN
                 FLOWIN=0.0
                 STROUT(ISTSG)=FLOWIN
                 IF(ISS.NE.0) DSTROT(ISTSG)=0.
C
C10----FLOW FROM LAKE COMPUTED USING MANNINGS FORMULA AND ASSUMING A
C         WIDE RECTANGULAR CHANNEL.
                ELSE IF (DLKSTR.GT.0.0.AND.ICALC.EQ.1) THEN
                  FLOWIN=(CONST/SEG(16,ISTSG))*SEG(9,ISTSG)*
     1                    ((DLKSTR)**(5./3.))*(DSQRT(SLOPE))
                  STROUT(ISTSG)=FLOWIN
                  IF(ISS.NE.0) DSTROT(ISTSG)=(5./3.)*FLOWIN/DLKSTR
C
C11----FLOW FROM LAKE COMPUTED USING MANNINGS FORMULA AND EIGHT POINT
C         CROSS SECTIONAL AREA.
                ELSE IF(DLKSTR.GT.0.0.AND.ICALC.EQ.2) THEN
                  CALL GWF1SFR1FLW(DLKSTR,XSEC,CONST,ISTSG,NSS,
     1                         SEG(16,ISTSG),SEG(17,ISTSG),SLOPE,
     2                         WETPERM,FLOWIN,WIDTH)
                  STROUT(ISTSG)=FLOWIN
                  IF(ISS.NE.0) THEN
                    DLKSTR1=DLKSTR*1.001
                    DLKSTR2=DLKSTR*0.999
                    CALL GWF1SFR1FLW(DLKSTR1,XSEC,CONST,ISTSG,NSS,
     1                           SEG(16,ISTSG),SEG(17,ISTSG),SLOPE,
     2                           WETPERM1,FLWDLK1,WIDTH1)
                    CALL GWF1SFR1FLW(DLKSTR2,XSEC,CONST,ISTSG,NSS,
     1                           SEG(16,ISTSG),SEG(17,ISTSG),SLOPE,
     2                           WETPERM2,FLWDLK2,WIDTH2)
                    DSTROT(ISTSG)=(FLWDLK1-FLWDLK2)/(DLKSTR1-DLKSTR2)
                  END IF
C
C12----FLOW FROM LAKE COMPUTED USING FORMULA-- Q=(DEPTH/CDPTH)**1/FDPTH).
                ELSE IF(DLKSTR.GT.0.0.AND.ICALC.EQ.3) THEN
                  CDPTH=SEG(9,ISTSG)
                  FDPTH=SEG(10,ISTSG)
                  FLOWIN=(DLKSTR/CDPTH)**(1/FDPTH)
                  STROUT(ISTSG)=FLOWIN
                  IF(ISS.NE.0) THEN
                    DLKSTR1=DLKSTR*1.001
                    DLKSTR2=DLKSTR*0.999
                    FLWDLK1=(DLKSTR1/CDPTH)**(1/FDPTH)
                    FLWDLK2=(DLKSTR2/CDPTH)**(1/FDPTH)
                    DSTROT(ISTSG)=(FLWDLK1-FLWDLK2)/(DLKSTR1-DLKSTR2)
                  END IF
C
C13----FLOW FROM LAKE COMPUTED USING TABULATED VALUES.
                ELSE IF(DLKSTR.GT.0.0.AND.ICALC.EQ.4) THEN
                  CALL GWF1SFR1TBF(FLOWIN,QSTAGE,DLKSTR,WIDTH,
     1                             ISEG(2,ISTSG),MAXPTS,NSS,NREACH,
     2                             ISTSG,KKITER,IOUT,0)
                  STROUT(ISTSG)=FLOWIN
                  IF(ISS.NE.0) THEN
                    DLKSTR1=DLKSTR*1.001
                    DLKSTR2=DLKSTR*0.999
                    CALL GWF1SFR1TBF(FLWDLK1,QSTAGE,DLKSTR1,WDTHLK1,
     1                               ISEG(2,ISTSG),MAXPTS,NSS,NREACH,
     2                               ISTSG,KKITER,IOUT,0)
                    CALL GWF1SFR1TBF(FLWDLK2,QSTAGE,DLKSTR2,WDTHLK2,
     1                               ISEG(2,ISTSG),MAXPTS,NSS,NREACH,
     2                               ISTSG,KKITER,IOUT,0)
                    DSTROT(ISTSG)=(FLWDLK1-FLWDLK2)/(DLKSTR1-DLKSTR2)
                  END IF
                ELSE IF (DLKSTR.LT.0.0.AND.ICALC.GT.0) THEN
                  FLOWIN=0.0
                  STROUT(ISTSG)=FLOWIN
                END IF
              END IF
          END IF
C
C14-----CHECK IF UPSTREAM SEGMENT GETS DIVERTED AND DETERMINE
C        SEGMENT NUMBER OF DIVERSION. CHANGES MADE BY CSTILLERY TO
C        ALLOW FOR MULTIPLE DIVERSIONS AT END OF A STREAM SEGMENT.
          IF(ISTSG.GT.1) THEN
            IPRVSG = ISTRM(4,LL)                                !CSTILLERY
            KSS=1                                               !CSTILLERY
            DO WHILE(KSS.LE.NSS)                                !CSTILLERY
              IDIVSEG=0
              IUPSEG=0
              DO WHILE(IPRVSG.NE.IUPSEG)                        !CSTILLERY
                IUPSEG=IDIVAR(1,KSS)
                IF(IUPSEG.EQ.IPRVSG) IDIVSEG=KSS
                KSS=KSS+1
                IF (KSS.GT.NSS) IPRVSG=IUPSEG                   !CSTILLERY
              END DO
              IF(IDIVSEG.GT.0) THEN
C
C15-----DETERMINE DIVERSION AND SUBTRACT IT FROM
C         FLOW AT END OF UPSTREAM SEGMENT.
                 DVRSFLW(IDIVSEG)=SEG(2,IDIVSEG)
                 UPFLW=SGOTFLW(IUPSEG)
                 IPRIOR=IDIVAR(2,IDIVSEG)
C16-----IF IPRIOR IS ZERO THEN FLOW DIVERTED CAN BE ALL OF
C         STREAMFLOW UP TO SPECIFIED FLOW.
                   IF (IPRIOR.EQ.0) THEN
                      DIF=UPFLW-DVRSFLW(IDIVSEG)
                      IF (DIF.GE.0.0) THEN
                         SGOTFLW(IUPSEG)=DIF
                      ELSE
                         SGOTFLW(IUPSEG)=0.0
                         DVRSFLW(IDIVSEG)=UPFLW
                      END IF
C
C17-----IF IPRIOR IS -1 THEN FLOW DIVERTED ONLY IF SPECIFIED FLOW
C         AVAILABLE OTHERWISE NO FLOW DIVERTED.
                   ELSE IF (IPRIOR.EQ.-1) THEN
                      DIF=UPFLW-DVRSFLW(IDIVSEG)
                      IF (DIF.GE.0.0) THEN
                         SGOTFLW(IUPSEG)=DIF
                      ELSE
                         DVRSFLW(IDIVSEG)=0.0
                      END IF
C
C18-----IF IPRIOR IS -2 THEN FLOW DIVERTED IS PERCENTAGE OF
C         AVAILABLE STREAMFLOW.
                   ELSE IF (IPRIOR.EQ.-2) THEN
                      PRCNT=DVRSFLW(IDIVSEG)
                      DVRSFLW(IDIVSEG)=UPFLW*PRCNT
                      SGOTFLW(IUPSEG)=UPFLW-DVRSFLW(IDIVSEG)
C
C19-----IF IPRIOR IS -3 THEN FLOW DIVERTED ONLY WHEN STREAMLFOW
C         EXCEEDS SPECIFIED FLOW (FLOOD CONTROL DIVERSION).
                   ELSE IF (IPRIOR.EQ.-3) THEN
                      IF (UPFLW.GT.DVRSFLW(IDIVSEG)) THEN
                         DVRSFLW(IDIVSEG)=UPFLW-SEG(2,IDIVSEG)
                         SGOTFLW(IUPSEG)=SEG(2,IDIVSEG)
                      ELSE
                         DVRSFLW(IDIVSEG)=0.0
                      END IF
                   END IF
              END IF
            END DO                                              !CSTILLERY
          END IF
C
C20-----SET FLOW INTO DIVERSION IF SEGMENT IS DIVERSION.
          IF(ISTSG.GT.1.AND.ISEG(3,ISTSG).EQ.6) THEN
             IF(IDIVAR(1,ISTSG).GT.0)FLOWIN=DVRSFLW(ISTSG)
          END IF
C
C21-----SUM TRIBUTARY OUTFLOW AND USE AS INFLOW INTO DOWNSTREAM SEGMENT.
          IF(ISTSG.GT.1.AND.ISEG(3,ISTSG).EQ.7) THEN
            ITRIB=1
            FLOWIN=0.0
            DO WHILE (ITRIB.LE.NSS)
                IF(ISTSG.EQ.IOTSG(ITRIB)) THEN
                  TRBFLW=SGOTFLW(ITRIB)
                  FLOWIN=FLOWIN+TRBFLW
                END IF
              ITRIB=ITRIB+1
            END DO
            FLOWIN=FLOWIN+SEG(2,ISTSG)
              IF (FLOWIN.LT.0) THEN
                FLOWIN=0.0
                WRITE (IOUT,4) ISTSG
    4           FORMAT (//2X,'*** WARNING *** FLOW INTO TRIBUTARY ',
     1              'STREAM SEGMENT No. ',I6,' WAS NEGATIVE; ',
     2              'FLOWIN RE-SET = 0.0'/)
              END IF
          END IF
C
C22-----IF REACH >1, SET INFLOW EQUAL TO OUTFLOW FROM UPSTREAM REACH.
        ELSE IF (NREACH.GT.1) THEN
          FLOWIN=STRM(9,LL)
        END IF
C
C23-----SEARCH FOR UPPER MOST ACTIVE CELL IN STREAM REACH.
        ILAY=IL
CERB--Changed to handle case of no active cell in stack of cells 3/25/05
        TOPCELL: DO WHILE(ILAY.LE.NLAY)
          IF (IBOUND(IC,IR,ILAY).EQ.0) THEN
            ILAY=ILAY+1
          ELSE
            EXIT TOPCELL
          ENDIF
        END DO TOPCELL
CERB end of change
        IF (ILAY.LE.NLAY)IL=ILAY
C
C24-----INITIALIZE VARIABLES. CHANGED 3/31/2005 dep
          IPRNDPTH=0
          DEPTH=STRM(7,L)
          IF(DEPTH.LE.0.D0)DEPTH=0.D0
          STRTOP=STRM(3,L)
          SBOT=STRM(4,L)
          WIDTH=STRM(5,L)
          STRLEN=STRM(1,L)
          H=HNEW(IC,IR,IL)
          AVHC=STRM(6,L)
          SBDTHK=STRM(8,L)
          HSTR=DEPTH+STRTOP
          CSTR=STRM(16,L)
          PRECIP=STRM(14,L)
          ETSTR=STRM(13,L)
          STRLEAK=STRLEN*AVHC
          DEPTHX=0.0D0
          DBLEAK=DLEAK
          DEPS=0.999*DLEAK
          DLH=DEPS
          DLHOLD=1.0D6
          ITOT=0
C       Added to skip calculations in C64 and C65 when no active cells.
C         dep 3/31/2005
          ISKIP=0
C       Moved initializations in C25B and C26 to here. dep
          IF(ICALC.EQ.1) THEN
            QCNST=CONST*WIDTH*DSQRT(SLOPE)/SEG(16,ISTSG)
          END IF
          IF (ICALC.EQ.3) THEN
            CDPTH=SEG(9,ISTSG)
            FDPTH=SEG(10,ISTSG)
            AWDTH=SEG(14,ISTSG)
            BWDTH=SEG(15,ISTSG)
          END IF

CERB moved this line from above C24 to here 3/30/05
        IF(IBOUND(IC,IR,IL).LE.0) THEN
           AVHC=0.0
           STRLEAK=0.0D0
           H=HSTR
           IF(ICALC.LE.1)ISKIP=1
        END IF
C
C25------BEGIN COMPUTATION OF STREAM DEPTH FOR ACTIVE CELL. DEP
C
C25B-----COMPUTE FLOW AT MIDPOINT OF REACH IGNORING STREAMBED LEAKAGE.

C erb -- Added 6/17/03; Added CSTR when ICALC = 0. dep 3/31/2005.
           if (icalc.eq.0) then
             flwmpt=FLOWIN+0.5*(STRM(12,L)-ETSTR+PRECIP)
             sfrq(4,l) = width
             IF(FLWMPT.LE.0.0D0)FLWMPT=0.0D0
             CSTR=(AVHC*WIDTH*STRLEN)/SBDTHK
           endif
           if (icalc.eq.1) then
             sfrq(4,l) = width
           endif
          IF(ICALC.EQ.1) THEN
            FLOWC=FLOWIN+(STRM(12,L)-ETSTR+PRECIP)
            FLWMPT=FLOWIN+0.5*(STRM(12,L)-ETSTR+PRECIP)
            IF(FLWMPT.LE.0.0D0)FLWMPT=0.0D0
            IF(FLOWC.LE.0.0D0)FLOWC=0.0D0
C         Moved initialization of QCNST to end of C24. dep 3/31/2005
            DEPTH=(FLWMPT/QCNST)**0.6D0
            IF(DEPTH.LE.0.0D0) THEN
              DEPTH=0.0D0
              HSTR=STRTOP
            ELSE
              HSTR=STRTOP+DEPTH
            END IF
            CSTR=(AVHC*WIDTH*STRLEN)/SBDTHK
          ELSE IF (ICALC.GE.2) THEN
            FLWMPT=FLOWIN+0.5*STRM(12,L)
            FLOWC=FLOWIN+STRM(12,L)
            IF(FLOWC.LE.0.0D0)FLOWC=0.0D0
C
C26-----CALCULATE AN INITIAL ESTIMATE OF FLOW IN CHANNEL.
            IF(FLWMPT.LE.0.0D0)THEN
               FLWMPT=0.0D0
               DEPTH=0.0D0
               WIDTH=0.0D0
               WETPERM=1.0D0
C        Added to skip newton method when reach is not in active cells
C            and FLWMPT is zero. Added dep 3/31/2005
               IF(AVHC.LE.0.0) ISKIP = 1
            END IF
            IF(ISKIP.EQ.0) THEN
              IF (FLWMPT.LE.0.0D0.AND.H.GT.STRTOP) THEN
                FLWEST=(STRLEN*AVHC/SBDTHK)*(ABS(STRTOP-H))
              ELSE
                FLWEST=FLWMPT
              END IF
              IF(FLWEST.GE.0.0D0) THEN
                IF(ICALC.EQ.2) THEN
                  CALL GWF1SFR1DPTH(FLWEST,XSEC,SLOPE,CONST,ISTSG,
     1                NREACH,NSS,SEG(16,ISTSG),SEG(17,ISTSG),
     2                WETPERM,DEPTH,ITSTR,WIDTH,IOUT,IPRNDPTH)
                ELSE IF(ICALC.EQ.3) THEN
C         Moved initialization of CDPTH,FDTPH,AWDTH,and BWDTH
C             to end of C24. dep 3/31/2005
                  DEPTH=CDPTH*(FLWEST**FDPTH)
                  WIDTH=AWDTH*(FLWEST**BWDTH)
                  WETPERM=WIDTH
                ELSE IF(ICALC.EQ.4) THEN
                  CALL GWF1SFR1TBD(FLWEST,QSTAGE,DEPTH,WIDTH,
     1                 ISEG(2,ISTSG),MAXPTS,NSS,NREACH,ISTSG,KKITER,
     2                 IOUT)
                  WETPERM=WIDTH
                END IF
              ELSE
                DEPTH=0.0D0
                WIDTH=1.0D0
                WETPERM=1.0D0
              END IF
              CSTR=(AVHC*WETPERM*STRLEN)/SBDTHK
              FLOWC=FLOWC+(PRECIP-ETSTR)*WIDTH
            END IF
          END IF

C
C27-----ESTIMATE DEPTH USING BISECTION METHOD WHEN ICALC IS GREATER THAN 0.
          IFLG=1
          IF(H.LE.STRTOP.AND.FLOWC.LE.0.0D0)IFLG=0
C       SKIP NEWTON METHOD WHEN ICALC IS 1 AND SURFACE INFLOW IS ZERO.
C         Added dep 3/31/2005
          IF(ICALC.EQ.1.AND.HSTR.LE.STRTOP) IFLG=0
C       SKIP NEWTON METHOD WHEN OUTSIDE ACTIVE AREA AND ISKIP IS 1.
C         Added dep 3/31/2005
          IF(ISKIP.NE.0) IFLG=0
          IF(ICALC.GE.1.AND.IFLG.EQ.1) THEN
C
C28-----ESTIMATE INITIAL ENDPOINTS.
C       ADDED DEP 5/20/2004
            ENPT1=0.0D0
            IF(DEPTH.GT.0.0D0)THEN
              IF((STRTOP-H).GT.0.0D0) THEN
                ENPT2=0.9D0*DEPTH
              ELSE
                ENPT2=1.1D0*(DEPTH-(STRTOP-H))
              END IF
            ELSE
              IF((STRTOP-H).GT.0.0D0) THEN
                ENPT2=1.0D0
              ELSE
                ENPT2=0.99D0*(H-STRTOP)
              END IF
            END IF
C
C29-----ESTIMATE FLOW AT ENDPOINT 1 DEP 05/22/04.
            IF(H.GT.STRTOP) THEN
              FLOBOT1=CSTR*(STRTOP-H)
              FLWEN1=FLWMPT-0.5D0*FLOBOT1
            ELSE
              FLOBOT1=0.0D0
              FLWEN1=FLWMPT
            END IF
C
C30-----ESTIMATE DEPTH FOR ENDPOINTS WHEN ICALC IS 1.
            IF(ICALC.EQ.1) THEN
              IF(ENPT2.GT.0.0D0) THEN
                IF(H.GT.SBOT)THEN
                  FLOBOT2=(CSTR*(STRTOP+ENPT2-H))
                ELSE
                  FLOBOT2=(CSTR*(STRTOP+ENPT2-SBOT))
                END IF
              ELSE
                IF(H.GT.STRTOP) THEN
                  FLOBOT2=CSTR*(STRTOP-H)
                ELSE
                  FLOBOT2=0.0D0
                END IF
              END IF
              IF(FLOBOT2.GT.FLOWC)FLOBOT2=FLOWC
              DEPTH2=((FLWMPT-0.5D0*FLOBOT2)/QCNST)**0.6D0
              DEPTH1=((FLWEN1-0.5D0*FLOBOT1)/QCNST)**0.6D0
C
C31-----ESTIMATE DEPTH, WIDTH AND WETTED PERIMETER WHEN
C         ICALC IS GREATER THAN OR EQUAL TO 2.
            ELSE IF(ICALC.GE.2) THEN
              IF(ICALC.EQ.2)THEN
                CALL GWF1SFR1FLW(ENPT2,XSEC,CONST,ISTSG,NSS,
     1                   SEG(16,ISTSG),SEG(17,ISTSG),SLOPE,WETPERM2,
     2                   FLWEN2,WIDTH2)
              ELSE IF(ICALC.EQ.3) THEN
                FLWEN2=(ENPT2/CDPTH)**(1/FDPTH)
                IF(FLWEN2.GT.0.0D0) THEN
                  WIDTH2=AWDTH*(FLWEN2**BWDTH)
                  WETPERM2=WIDTH2
                ELSE
                  WIDTH2=0.0D0
                  WETPERM2=1.0D0
                END IF
              ELSE IF(ICALC.EQ.4) THEN
                  CALL GWF1SFR1TBF(FLWEN2,QSTAGE,ENPT2,WIDTH2,
     1               ISEG(2,ISTSG),MAXPTS,NSS,NREACH,ISTSG,KKITER,
     2               IOUT,0)
                  WETPERM2=WIDTH2
              END IF
C
C32-----ESTIMATE LEAKAGE THROUGH STREAMBED WHEN ICALC GREATER THAN OR
C         EQUAL TO 2.
              IF(WIDTH2.GT.0.0D0)THEN
                FLWPET2=(PRECIP-ETSTR)*WIDTH2
                IF(H.GT.SBOT) THEN
                  FLOBOT2=((AVHC*WETPERM2*STRLEN/SBDTHK)*
     1                      (STRTOP+ENPT2-H))
                ELSE
                  FLOBOT2=((AVHC*WETPERM2*STRLEN/SBDTHK)*
     1                     (STRTOP+ENPT2-SBOT))
                END IF
              ELSE
                FLWPET2=(PRECIP-ETSTR)
                IF(FLWPET2.LE.0.0D0)FLWPET2=0.0D0
                IF(H.GT.STRTOP) THEN
                  FLOBOT2=((AVHC*1.0D0*STRLEN/SBDTHK)*
     1                      (STRTOP-H))
                ELSE
                  FLOBOT2=0.0D0
                END IF
              END IF
              FLWMPT2=FLWMPT
              IF(FLOBOT2.GE.FLOWC+FLWPET2)THEN
                 FLOBOT2=FLOWC+FLWPET2
                 FLWMPT2=0.5*(FLOWC+FLWPET2)
              END IF
              FLWEN2=FLWMPT2
              IF(FLWEN1.LE.0.0D0) THEN
                DEPTH1=0.0D0
                WIDTH1=0.0D0
                WETPERM=1.0D0
              ELSE
                IF(ICALC.EQ.2) THEN
                  CALL GWF1SFR1DPTH(FLWEN1,XSEC,SLOPE,CONST,ISTSG,
     1                  NREACH,NSS,SEG(16,ISTSG),SEG(17,ISTSG),
     2                  WETPERM1,DEPTH1,ITSTR,WIDTH1,IOUT,IPRNDPTH)
                ELSE IF (ICALC.EQ.3) THEN
                    DEPTH1=CDPTH*(FLWEN1**FDPTH)
                    WIDTH1=AWDTH*(FLWEN1**BWDTH)
                    WETPERM1=WIDTH1
                ELSE IF(ICALC.EQ.4) THEN
                  CALL GWF1SFR1TBD(FLWEN1,QSTAGE,DEPTH1,WIDTH1,
     1                  ISEG(2,ISTSG),MAXPTS,NSS,NREACH,ISTSG,KKITER,
     2                  IOUT)
                END IF
              END IF
C
C33-----IF FLOW AT ENDPOINT 2 IS LESS THAN OR EQUAL TO ZERO, SET DEPTH2,
C             AND WIDTH2 TO ZERO, AND WETPERM2 TO ONE.
              IF(FLWEN2.LE.0.0D0) THEN
                DEPTH2=0.0D0
                WIDTH2=0.0D0
                WETPERM2=1.0D0
C
C34-----OTHERWISE CALCULATE DEPTH2,WIDTH2,AND WETPERM2.
              ELSE
                IF(ICALC.EQ.2) THEN
                  CALL GWF1SFR1DPTH(FLWEN2,XSEC,SLOPE,CONST,ISTSG,
     1                  NREACH,NSS,SEG(16,ISTSG),SEG(17,ISTSG),
     2                  WETPERM2,DEPTH2,ITSTR,WIDTH2,IOUT,IPRNDPTH)
                ELSE IF (ICALC.EQ.3) THEN
                  DEPTH2=CDPTH*(FLWEN2**FDPTH)
                  WIDTH2=AWDTH*(FLWEN2**BWDTH)
                  WETPERM2=WIDTH2
                ELSE IF(ICALC.EQ.4) THEN
                  CALL GWF1SFR1TBD(FLWEN2,QSTAGE,DEPTH2,WIDTH2,
     1                  ISEG(2,ISTSG),MAXPTS,NSS,NREACH,ISTSG,KKITER,
     2                  IOUT)
                END IF
              END IF
            END IF
C
C35-----DETERMINE ROOT FOR ENDPOINT 1 WHEN DEPTH IS GREATER THAN 0.
            IF(DEPTH1.GT.0.0D0)THEN
              F1=ENPT1-DEPTH1
            ELSE
              ENPT1=0.0D0
              WIDTH1=0.0D0
              WETPERM1=1.0D0
              F1=ENPT1-0.0D0
C
C36-----DETERMINE ROOT FOR ENDPOINT 2 WHEN DEPTH IS GREATER THAN 0.
            END IF
            IF(DEPTH2.GT.0.0D0) THEN
              F2=ENPT2-DEPTH2
              IF(F2.LT.0.0D0)ENPT2=DEPTH2
            ELSE
              DEPTH2=0.0D0
              WIDTH2=0.0D0
              WETPERM2=1.0D0
              F2=ENPT2-0.0D0
            END IF
            FPOLD=0.0D0
            IFLG=1
C
C37-----ITERATE THROUGH NEWTON METHOD TO FIND ESTIMATE OF STREAM DEPTH
C        AND STREAMBED LEAKAGE WHEN ICALC IS GREATER THAN 0.
            DEPTHP=(ENPT1+ENPT2)/2.0
            DEPTHX=DEPTHP
            IIC=0
            IIC2=0
            IIC3=0
            FLOBOTOLD=0.0D0 ! ERB, guessing this belongs here, 8/6/04
            ERROLD=DLHOLD
            DO WHILE (IFLG.EQ.1)
              ITOT=ITOT+1
              IBFLG=0
              DEPTH1=DEPTHP
              DEPTH2=DEPTH1+2.0D0*(DEPS)
C
C38-----CALCULATE FLOBOT1 AND FLOBOT2 FOR ICALC =1.
                IF(ICALC.EQ.1)THEN
                   FLWMDPT1=QCNST*(DEPTH1)**(5.D0/3.D0)
                   FLWMDPT2=QCNST*(DEPTH2)**(5.D0/3.D0)
                  IF(H.GT.SBOT) THEN
                       FLOBOT1=CSTR*((DEPTH1+DLH+STRTOP)-H)
                       FLOBOT2=CSTR*((DEPTH2+DLH+STRTOP)-H)
                  ELSE
                       FLOBOT1=CSTR*((DEPTH1+DLH+STRTOP)-SBOT)
                       FLOBOT2=CSTR*((DEPTH2+DLH+STRTOP)-SBOT)
                  END IF
C
C39-----IF FLOBOT1 LIMITED BY FLOW IN CHANNEL USE BISECTION.
                  IF(FLOBOT1.GE.FLOWC) THEN
                    ENPT2=DEPTHP
                    DEPTHP=(ENPT1+ENPT2)/2.0D0
                    IF(H.GT.SBOT)THEN
                      FLOBOTP=CSTR*((DEPTHP+STRTOP)-H)
                    ELSE
                      FLOBOTP=CSTR*((DEPTHP+STRTOP)-SBOT)
                    END IF
                    IF(0.5D0*FLOBOTP.GT.FLWMPT)THEN
                      FLOBOTP=FLOWC
                    END IF
                    DEPTHX=((FLWMPT-0.5D0*FLOBOTP)/QCNST)**0.6D0
                    IBFLG=1
                  ELSE
                    FHSTR1=(FLWMPT-0.5D0*FLOBOT1)-(FLWMDPT1)
                    FHSTR2=(FLWMPT-0.5D0*FLOBOT2)-(FLWMDPT2)
                  END IF
                ELSE IF(ICALC.GE.2) THEN
C
C40-----CALCULATE NEWTON VARIABLES FOR ICALC =2.
                  IF (ICALC.EQ.2) THEN
                    DEPTHA=DEPTH1-(DEPS*DEPTH1)
                    IF(DEPTHA.LE.0.0D0)DEPTHA=DEPTH1
                    DEPTHB=DEPTH1+(DEPS*DEPTH1)
                    IF(DEPTHB.LE.0.0D0)DEPTHB=DEPS
                    DEPTH2=DEPTH1+(2.D0*DEPS)
                    DEPTHC=DEPTH2-(DEPS*DEPTH2)
                    IF(DEPTHC.LE.0.0D0)DEPTHC=DEPTH2
                    DEPTHD=DEPTH2+(DEPS*DEPTH2)
                    IF(DEPTHD.LE.0.0D0)DEPTHD=DEPS
                    CALL GWF1SFR1FLW(DEPTHA,XSEC,CONST,ISTSG,NSS,
     1                           SEG(16,ISTSG),SEG(17,ISTSG),SLOPE,
     2                           WETPERMA,FLWMDPTA,WIDTHA)
                    CALL GWF1SFR1FLW(DEPTHB,XSEC,CONST,ISTSG,NSS,
     1                           SEG(16,ISTSG),SEG(17,ISTSG),SLOPE,
     2                           WETPERMB,FLWMDPTB,WIDTHB)
                    CALL GWF1SFR1FLW(DEPTHC,XSEC,CONST,ISTSG,NSS,
     1                           SEG(16,ISTSG),SEG(17,ISTSG),SLOPE,
     2                           WETPERMC,FLWMDPTC,WIDTHC)
                    CALL GWF1SFR1FLW(DEPTHD,XSEC,CONST,ISTSG,NSS,
     1                           SEG(16,ISTSG),SEG(17,ISTSG),SLOPE,
     2                           WETPERMD,FLWMDPTD,WIDTHD)
                    CALL GWF1SFR1FLW(DEPTH1,XSEC,CONST,ISTSG,NSS,
     1                           SEG(16,ISTSG),SEG(17,ISTSG),SLOPE,
     2                           WETPERM1,FLWMDPT1,WIDTH1)
                    CALL GWF1SFR1FLW(DEPTH2,XSEC,CONST,ISTSG,NSS,
     1                           SEG(16,ISTSG),SEG(17,ISTSG),SLOPE,
     2                           WETPERM2,FLWMDPT2,WIDTH2)
C
C41-----CALCULATE NEWTON VARIABLES FOR ICALC=3.
                  ELSE IF (ICALC.EQ.3) THEN
                    FLWMDPT1=(DEPTH1/CDPTH)**(1/FDPTH)
                    FLWMDPT2=(DEPTH2/CDPTH)**(1/FDPTH)
                    IF(FLWMDPT1.GE.0.0D0) THEN
                      WIDTH1=AWDTH*(FLWMDPT1**BWDTH)
                      WETPERM1=WIDTH1
                    ELSE
                      WIDTH1=0.0D0
                      WETPERM1=1.0D0
                    END IF
                    IF(FLWMPT2.GE.0.0D0) THEN
                      WIDTH2=AWDTH*(FLWMDPT2**BWDTH)
                      WETPERM2=WIDTH2
                    ELSE
                      WIDTH2=0.0D0
                      WETPERM2=1.0D0
                    END IF
                    DEPTHA=DEPTH1-(DEPS*DEPTH1)
                    IF(DEPTHA.LE.0.0D0)DEPTHA=DEPTH1
                    DEPTHB=DEPTH1+(DEPS*DEPTH1)
                    IF(DEPTHB.LE.0.0D0)DEPTHB=DEPS
                    DEPTH2=DEPTH1+(2.0D0*DEPS)
                    DEPTHC=DEPTH2-(DEPS*DEPTH2)
                    IF(DEPTHC.LE.0.0D0)DEPTHC=DEPTH2
                    DEPTHD=DEPTH2+(DEPS*DEPTH2)
                    IF(DEPTHD.LE.0.0D0)DEPTHD=DEPS
                    FLWMDPTA=(DEPTHA/CDPTH)**(1/FDPTH)
                    FLWMDPTB=(DEPTHB/CDPTH)**(1/FDPTH)
                    FLWMDPTC=(DEPTHC/CDPTH)**(1/FDPTH)
                    FLWMDPTD=(DEPTHD/CDPTH)**(1/FDPTH)
                    WIDTHA=AWDTH*(FLWMDPTA**BWDTH)
                    WIDTHB=AWDTH*(FLWMDPTB**BWDTH)
                    WIDTHC=AWDTH*(FLWMDPTC**BWDTH)
                    WIDTHD=AWDTH*(FLWMDPTD**BWDTH)
                    WETPERMA=WIDTHA
                    WETPERMB=WIDTHB
                    WETPERMC=WIDTHC
                    WETPERMD=WIDTHD
C
C42-----CALCULATE NEWTON VARIABLES FOR ICALC =4.
                  ELSE IF (ICALC.EQ.4) THEN
                    DEPTHA=DEPTH1-(DEPS*DEPTH1)
                    IF(DEPTHA.LE.0.0D0)DEPTHA=DEPTH1
                    DEPTHB=DEPTH1+(DEPS*DEPTH1)
                    IF(DEPTHB.LE.0.0D0)DEPTHB=DEPS
                    DEPTHC=DEPTH2-(DEPS*DEPTH2)
                    IF(DEPTHC.LE.0.0D0)DEPTHC=DEPTH2
                    DEPTHD=DEPTH2+(DEPS*DEPTH2)
                    IF(DEPTHD.LE.0.0D0)DEPTHD=DEPS
                    CALL GWF1SFR1TBF(FLWMDPTA,QSTAGE,DEPTHA,WIDTHA,
     1                             ISEG(2,ISTSG),MAXPTS,NSS,NREACH,
     2                             ISTSG,KKITER,IOUT,0)
                    CALL GWF1SFR1TBF(FLWMDPTB,QSTAGE,DEPTHB,WIDTHB,
     1                             ISEG(2,ISTSG),MAXPTS,NSS,NREACH,
     2                             ISTSG,KKITER,IOUT,0)
                    CALL GWF1SFR1TBF(FLWMDPTC,QSTAGE,DEPTHC,WIDTHC,
     1                             ISEG(2,ISTSG),MAXPTS,NSS,NREACH,
     2                             ISTSG,KKITER,IOUT,0)
                    CALL GWF1SFR1TBF(FLWMDPTD,QSTAGE,DEPTHD,WIDTHD,
     1                             ISEG(2,ISTSG),MAXPTS,NSS,NREACH,
     2                             ISTSG,KKITER,IOUT,0)
                    CALL GWF1SFR1TBF(FLWMDPT1,QSTAGE,DEPTH1,WIDTH1,
     1                             ISEG(2,ISTSG),MAXPTS,NSS,NREACH,
     2                             ISTSG,KKITER,IOUT,0)
                    CALL GWF1SFR1TBF(FLWMDPT2,QSTAGE,DEPTH2,WIDTH2,
     1                             ISEG(2,ISTSG),MAXPTS,NSS,NREACH,
     2                             ISTSG,KKITER,IOUT,0)
                    WETPERMA=WIDTHA
                    WETPERMB=WIDTHB
                    WETPERMC=WIDTHC
                    WETPERMD=WIDTHD
                    WETPERM1=WIDTH1
                    WETPERM2=WIDTH2
                  END IF
C
C43-----CALCULATE DERIVATIVES FOR DEPTH DEPENDENT VARIABLES FOR ICALC>1.
                  DLPP1=(PRECIP*(WIDTHA-WIDTHB))/(DEPTHA-DEPTHB)
                  DLPP2=(PRECIP*(WIDTHC-WIDTHD))/(DEPTHC-DEPTHD)
                  DLET1=(ETSTR*(WIDTHA-WIDTHB))/(DEPTHA-DEPTHB)
                  DLET2=(ETSTR*(WIDTHC-WIDTHD))/(DEPTHC-DEPTHD)
                  DLWP1=(WETPERMA-WETPERMB)/(DEPTHA-DEPTHB)
                  DLWP2=(WETPERMC-WETPERMD)/(DEPTHC-DEPTHD)
                  PP1=PRECIP*(WIDTH1+DLPP1*DLH)
                  PP2=PRECIP*(WIDTH2+DLPP2*DLH)
                  ET1=ETSTR*(WIDTH1+DLET1*DLH)
                  ET2=ETSTR*(WIDTH2+DLET2*DLH)
                  CSTR1=((WETPERM1+DLWP1*DLH)*STRLEAK)/SBDTHK
                  CSTR2=((WETPERM2+DLWP2*DLH)*STRLEAK)/SBDTHK
C
C44-----CALCULATE FLOBOT1 AND FLOBOT2 WHEN ICALC>1.
                  IF(H.LT.SBOT)THEN
                     FLOBOT1=CSTR1*((DEPTH1+DLH+STRTOP)-SBOT)
                     FLOBOT2=CSTR2*((DEPTH2+DLH+STRTOP)-SBOT)
                  ELSE
                     FLOBOT1=CSTR1*((DEPTH1+DLH+STRTOP)-H)
                     FLOBOT2=CSTR2*((DEPTH2+DLH+STRTOP)-H)
                  END IF
C
C45-----DETERMINE IF LEAKAGE LIMITED BY FLOW IN CHANNEL.
                  IF(WIDTH1.GT.0.0D0)THEN
                    FLWPET1=PRECIP*(WIDTH1+DLPP1*DLH)-
     1              ETSTR*(WIDTH1+DLET1*DLH)
                  ELSE
                    FLWPET1=(PRECIP-ETSTR)
                    IF(FLWPET1.LE.0.0D0)FLWPET1=0.0D0
                  END IF
C
C46-----IF LEAKAGE LIMITED BY FLOW USE BISECTION.
                  IF(FLOBOT1.GT.FLOWC+FLWPET1)THEN
                    DEPTHP=(ENPT1+ENPT2)*0.5D0
                    IBFLG=1
                    IF(ICALC.EQ.2) THEN
                      CALL GWF1SFR1FLW(DEPTHP,XSEC,CONST,ISTSG,NSS,
     1                           SEG(16,ISTSG),SEG(17,ISTSG),SLOPE,
     2                           WETPERMP,FLWX,WIDTHA)
                    ELSE IF (ICALC.EQ.3) THEN
                      FLWX=(DEPTHP/CDPTH)**(1/FDPTH)
                      IF(FLWX.GT.0.0D0) THEN
                        WIDTHP=AWDTH*(FLWX**BWDTH)
                        WETPERMP=WIDTHP
                      ELSE
                        WIDTHP=0.0D0
                        WETPERMP=1.0D0
                      END IF
                    ELSE IF(ICALC.EQ.4) THEN
                      CALL GWF1SFR1TBF(FLWX,QSTAGE,DEPTHP,WIDTHP,
     1                             ISEG(2,ISTSG),MAXPTS,NSS,NREACH,
     2                             ISTSG,KKITER,IOUT,0)
                        WETPERMP=WIDTHP
                    END IF
                    CSTR1=WETPERMP*STRLEAK/SBDTHK
                    IF(H.GT.SBOT)THEN
                      FLOBOTP=CSTR1*((DEPTHP+STRTOP)-H)
                    ELSE
                      FLOBOTP=CSTR1*((DEPTHP+STRTOP)-SBOT)
                    END IF
                    IF(FLOBOTP.GT.FLOWC+FLWPET1)THEN
                      FLOBOTP=FLOWC+FLWPET1
                    END IF
                    FLWMPT=FLWMPT+0.5D0*FLWPET1
                    FLWX=FLWMPT-0.5D0*FLOBOTP
                    IF(FLWX.GT.0.0D0)THEN
                      IF(ICALC.EQ.2) THEN
                        CALL GWF1SFR1DPTH(FLWX,XSEC,SLOPE,CONST,ISTSG,
     1                      NREACH,NSS,SEG(16,ISTSG),SEG(17,ISTSG),
     2                      WETPERMP,DEPTHX,ITSTR,WIDTHP,IOUT,IPRNDPTH)
                      ELSE IF (ICALC.EQ.3) THEN
                          DEPTHX=CDPTH*(FLWX**FDPTH)
                          WIDTHP=AWDTH*(FLWX**BWDTH)
                          WETPERMX=WIDTHX
                      ELSE IF(ICALC.EQ.4) THEN
                        CALL GWF1SFR1TBD(FLWX,QSTAGE,DEPTHX,WIDTHX,
     1                     ISEG(2,ISTSG),MAXPTS,NSS,NREACH,ISTSG,KKITER,
     2                     IOUT)
                        WETPERMX=WIDTHX
                      END IF
                    ELSE
                      DEPTHX=0.0D0
                      WIDTHX=0.0D0
                      WETPERMX=1.0D0
                    END IF
C
C47-----IF NOT FLOW LIMITED CALCULATE LEAKAGE FROM NEWTON METHOD.
                  ELSE
                    FHSTR1=(FLWMPT-0.5D0*(PP1-ET1+FLOBOT1))-(FLWMDPT1)
                    FHSTR2=(FLWMPT-0.5D0*(PP2-ET2+FLOBOT2))-(FLWMDPT2)
                  END IF
                  IF(DEPTHP.EQ.0.0D0) THEN
                    DEPTHX=DEPTHP
                    FLOBOTP=0.0D0
                    WIDTHX=0.0D0
                    WETPERMX=1.0D0
                    IFLG=0
                  END IF
                END IF
                IF(IBFLG.EQ.0) THEN
                  DLFH=(FHSTR1-FHSTR2)/(DEPTH1-DEPTH2)
                  IF(DABS(DLFH).LE.DBLEAK)DLFH=0.0D0
                  IF(DABS(DLFH).GT.0.0D0)THEN
                    DLH=-FHSTR1/DLFH
                  ELSE
                    DLH=0.0D0
                  END IF
                  DEPTHP=DEPTH1+DLH
                  IF(IFLG.GT.0) THEN
                    IF((DEPTHP.GE.ENPT2).OR.(DEPTHP.LE.ENPT1)) THEN
                      IF(DABS(DLH)>DABS(DLHOLD).OR.DEPTHP.LT.0.0D0)THEN
                        DEPTHP=(ENPT1+ENPT2)*0.5D0
                        IBFLG=1
                      END IF
                    END IF
C
C48----SET FLAGS TO DETERMINE IF NEWTON METHOD OSCILLATES OR IF
C               CONVERGENCE IS SLOW.
                    IF(FLOBOT1*FLOBOTOLD.LT.0.0D0)THEN
                      IIC2=IIC2+1
                    ELSE
                      IIC2=0
                    END IF
                    IF(FLOBOT1.LT.0.0D0)THEN
                      IIC3=IIC3+1
                    ELSE
                      IIC3=0
                    END IF
                    IF(DLH*DLHOLD.LT.0.0D0.OR.
     1                 DABS(DLH).GT.DABS(DLHOLD))THEN
                      IIC=IIC+1
                    END IF
                    IIC4=0
                    IF(IIC3.GT.7.AND.IIC.GT.12) IIC4=1
C
C49----IF NEWTON METHOD OSCILLATES OR IF CONVERGENCE IS SLOW,
C                SWITCH TO BISECTION.
                    IF(IIC2.GT.7.OR.IIC.GT.12.OR.IIC4.EQ.1) THEN
                      IBFLG=1
                      DEPTHP=(ENPT1+ENPT2)*0.5D0
                    END IF
C
C50----COMPUTE FLOBOTP ON BASIS OF DEPTHP AND THEN ESTIMATE DEPTHX FROM
C                FLOBOTP.
                    IF(ICALC.EQ.1)THEN
                      IF(H.GT.SBOT) THEN
                        FLOBOTP=(CSTR*(STRTOP+DEPTHP-H))
                      ELSE
                        FLOBOTP=(CSTR*(STRTOP+DEPTHP-SBOT))
                      END IF
                      IF(FLOBOTP.GE.FLOWC) THEN
                        FLOBOTP=FLOWC
                        IF(ENPT1==ENPT2)
     1                     DEPTHP=((FLWMPT-0.5D0*FLOBOTP)/QCNST)**0.6D0
                      END IF
                      DEPTHX=((FLWMPT-0.5D0*FLOBOTP)/QCNST)**0.6D0
                    ELSE IF(ICALC.GE.2) THEN
                      IF (ICALC.EQ.2) THEN
                        CALL GWF1SFR1FLW(DEPTHP,XSEC,CONST,ISTSG,NSS,
     1                     SEG(16,ISTSG),SEG(17,ISTSG),SLOPE,WETPERMP,
     2                     FLWP,WIDTHP)
                      ELSE IF (ICALC.EQ.3) THEN
                        FLWP=(DEPTHP/CDPTH)**(1/FDPTH)
                        IF(FLWP.GT.0.0D0) THEN
                          WIDTHP=AWDTH*(FLWP**BWDTH)
                          WETPERMP=WIDTHP
                        ELSE
                          WIDTHP=0.0D0
                          WETPERMP=1.0D0
                        END IF
                      ELSE IF (ICALC.EQ.4) THEN
                        CALL GWF1SFR1TBF(FLWP,QSTAGE,DEPTHP,WIDTHP,
     1                         ISEG(2,ISTSG),MAXPTS,NSS,NREACH,
     2                         ISTSG,KKITER,IOUT,0)
                        WETPERMP=WIDTHP
                      END IF
                      IF(WIDTHP.GT.0.0D0)THEN
                        FLWPETP=(PRECIP-ETSTR)*WIDTHP
                      ELSE
                        FLWPETP=(PRECIP-ETSTR)
                        IF(FLWPETP.LE.0.0D0)FLWPETP=0.0D0
                      END IF
                      IF(H.GT.SBOT) THEN
                        FLOBOTP=((AVHC*WETPERMP*STRLEN/SBDTHK)*
     1                          (STRTOP+DEPTHP-H))
                      ELSE
                        FLOBOTP=((AVHC*WETPERMP*STRLEN/SBDTHK)*
     1                          (STRTOP+DEPTHP-SBOT))
                      ENDIF
                      FLWMPT=FLWMPT+0.5D0*FLWPETP
                      FLWX=FLWMPT-0.5D0*FLOBOTP
C
C51-----LEAKAGE LIMITED BY FLOW FOR ICALC GREATER OR EQUAL TO 2.
C                 SWITCH TO BISECTION.
                      IF(FLOBOTP.GT.FLOWC+FLWPETP)THEN
                        DEPTHP=(ENPT1+ENPT2)*0.5D0
                        IBFLG=1
                        IF (ICALC.EQ.2) THEN
                          CALL GWF1SFR1FLW(DEPTHP,XSEC,CONST,ISTSG,NSS,
     1                     SEG(16,ISTSG),SEG(17,ISTSG),SLOPE,WETPERMP,
     2                     FLWP,WIDTHP)
                        ELSE IF (ICALC.EQ.3) THEN
                          FLWP=(DEPTHP/CDPTH)**(1/FDPTH)
                          IF(FLWP.GT.0.0D0) THEN
                            WIDTHP=AWDTH*(FLWP**BWDTH)
                            WETPERMP=WIDTHP
                          ELSE
                            WIDTHP=0.0D0
                            WETPERMP=1.0D0
                          END IF
                        ELSE IF (ICALC.EQ.4) THEN
                          CALL GWF1SFR1TBF(FLWP,QSTAGE,DEPTHP,WIDTHP,
     1                         ISEG(2,ISTSG),MAXPTS,NSS,NREACH,
     2                         ISTSG,KKITER,IOUT,0)
                          WETPERMP=WIDTHP
                        END IF
                        IF(WIDTHP.GT.0.0D0)THEN
                          FLWPETP=(PRECIP-ETSTR)*WIDTHP
                        ELSE
                          FLWPETP=(PRECIP-ETSTR)
                          IF(FLWPETP.LE.0.0D0)FLWPETP=0.0D0
                        END IF
                        IF(H.GT.SBOT) THEN
                          FLOBOTP=((AVHC*WETPERMP*STRLEN/SBDTHK)*
     1                          (STRTOP+DEPTHP-H))
                        ELSE
                          FLOBOTP=((AVHC*WETPERMP*STRLEN/SBDTHK)*
     1                          (STRTOP+DEPTHP-SBOT))
                        ENDIF
                        FLWMPT=FLWMPT+0.5D0*FLWPETP
                        FLWX=FLWMPT-0.5D0*FLOBOTP
                        IF(FLOBOTP.GE.FLOWC+FLWPETP)FLOBOTP=
     1                     FLOWC+FLWPETP
                      END IF
C
C53-----ESTIMATE DEPTHX WHEN ICALC IS GREATER THAN OR EQUAL TO 2.
                      IF(FLWX.GT.0.0D0)THEN
                        IF(ICALC.EQ.2) THEN
                          CALL GWF1SFR1DPTH(FLWX,XSEC,SLOPE,CONST,
     1                       ISTSG,NREACH,NSS,SEG(16,ISTSG),
     2                       SEG(17,ISTSG),WETPERMX,DEPTHX,ITSTR,
     3                       WIDTHX,IOUT,IPRNDPTH)
                        ELSE IF (ICALC.EQ.3) THEN
                            DEPTHX=CDPTH*(FLWX**FDPTH)
                            WIDTHX=AWDTH*(FLWX**BWDTH)
                            WETPERMX=WIDTHX
                        ELSE IF (ICALC.EQ.4) THEN
                          CALL GWF1SFR1TBD(FLWX,QSTAGE,DEPTHX,WIDTHX,
     1                    ISEG(2,ISTSG),MAXPTS,NSS,NREACH,ISTSG,
     2                    KKITER,IOUT)
                          WETPERMX=WIDTHX
                        END IF
                      ELSE
                        DEPTHX=0.0D0
                        WIDTHX=0.0D0
                        WETPERMX=1.0D0
                      END IF
                    END IF
                  END IF
                END IF
C
C54-----COMPUTE DIFFERENCE BETWEEN DEPTHP AND DEPTHX.
                FP=DEPTHP-DEPTHX
                IF(IBFLG==1)DLH=FP
C
C55-----CHANGE ENDPOINTS IF BISECTION HAS BEEN USED.
                IF(IBFLG.EQ.1)THEN
                  IF(F1*FP.LT.0.0D0) THEN
C
C56-----ROOT IS BETWEEN F1 AND FP.
                    ENPT2=DEPTHP
                    F2=FP
                  ELSE
C
C57-----ROOT IS BETWEEN FP AND F2.
                    ENPT1=DEPTHP
                    F1=FP
C
C58-----CALCULATE ERROR.
                  END IF
                  ERR=MIN(DABS(FP),DABS(ENPT2-ENPT1))
                ELSE
                  ERR=DLH
                END IF
C
C59-----SET DEPTH TO DEPTHP AND FLOBOT TO FLOBOTP IS ERROR LESS
C               THAN TOLERANCE.
                IF(DABS(ERR).LT.DBLEAK) THEN
                  IFLG=0
                  DEPTH=DEPTHP
                  FLOBOT=FLOBOTP
                  IF(ICALC.GE.2)THEN
                    WIDTH=WIDTHP
                    WETPERM=WETPERMP
                    FLOWC=FLOWIN+STRM(12,L)-ETSTR*
     1                      WIDTH+PRECIP*WIDTH
                    FLWMPT=FLOWIN +0.5D0*(STRM(12,L)+PRECIP*WIDTH-
     1                       ETSTR*WIDTH-FLOBOT)
                  END IF
                END IF
C
C60-----PRINT WARNING THAT REACH FAILED TO CONVERGE AFTER 100 ITERATIONS.
C             AND SET DEPTH TO DEPTHP AND FLOBOT TO FLOBOTP.
                IF (ITOT.GE.100) THEN
                  IFLG=0
                  WRITE(IOUT,12)ISTSG,NREACH,KKITER,ERR,ERROLD
   12             FORMAT (//5X,'*** WARNING *** SFR FAILED TO ',
     1                 'CONVERGE FOR SEGMENT ',I6,' REACH NO. ',I6,
     2                 ' MODFLOW ITERATION IS ',I6,' LAST ITERATION ',
     3                  G20.10,' PREVIOUS ITERATION ',G20.10)
                  DEPTH=DEPTHP
                  FLOBOT=FLOBOTP
                  IF(ICALC.GE.2)THEN
                    WIDTH=WIDTHP
                    WETPERM=WETPERMP
                    FLOWC=FLOWIN+STRM(12,L)-ETSTR*WIDTH+PRECIP*WIDTH
                    FLWMPT=FLOWIN +0.5*(STRM(12,L)+PRECIP*WIDTH-
     1                       ETSTR*WIDTH-FLOBOT)
                  END IF
                END IF
               ERROLD=ERR
               DLHOLD=DLH
               FLOBOTOLD=FLOBOT1
               IF(IBFLG.EQ.1) FLOBOTOLD=FLOBOTP
C
CERB -- Need to check that assignment of SFRQ(4,L) belongs here
              SFRQ(4,L)=WIDTH
C
C61-----END OF NEWTON LOOP.
            END DO
C
C62-----DEFINE HSTR, CSTR, WIDTH, AND FLOWOT.
            HSTR=DEPTH+STRM(3,L)
            IF(ICALC.GE.2)CSTR=(AVHC*WETPERM*STRLEN)/SBDTHK
          END IF
C
C63-----COMPUTE FLOW AND DEPTH IN REACH WHEN MODEL CELL IS INACTIVE ROUTE
C          AND ISKIP TEST NOT ZERO.  Revised dep 3/31/2005
        IF(ISKIP.NE.0.OR.ITOT.EQ.0) THEN
            IF(ICALC.EQ.0.OR.ICALC.EQ.1)THEN
               FLOWC=FLOWIN+STRM(12,L)+(PRECIP-ETSTR)
               FLWMPT=FLOWIN+0.5*(STRM(12,L)-ETSTR+PRECIP)
               IF(FLOWIN+STRM(12,L).LE.0.0D0) THEN
                  IF((PRECIP-ETSTR).LE.0.0)THEN
                     ETSTR=PRECIP
                     FLOWC=0.0D0
                  ELSE
                     FLOWC=PRECIP-ETSTR
                     FLWMPT=0.5D0*(PRECIP-ETSTR)
                  END IF
               END IF
               IF(ICALC.EQ.1)DEPTH=(FLWMPT/QCNST)**0.6D0
            ELSE IF(ICALC.GE.2) THEN
                  DEPTH=0.0D0
                  CSTR=0.0D0
               IF(ICALC.EQ.2) THEN
                  WIDTH=XSEC(6,ISTSG)-XSEC(3,ISTSG)
               ELSE IF (ICALC.EQ.3) THEN
                    WIDTH=10.0
               ELSE IF (ICALC.EQ.4) THEN
                    WIDTH=(QSTAGE(1+2*ISEG(2,ISTSG),ISTSG)+
     +                    QSTAGE(3*ISEG(2,ISTSG),ISTSG))/2.0
               END IF
               FLOWC=(PRECIP-ETSTR)*WIDTH
               FLWMPT=0.5*FLOWC
               IF(FLOWC.LE.0.0D0)THEN
                    FLOWC=0.0D0
                    ETSTR=PRECIP
                    FLWMPT=0.0D0
               END IF
            END IF
C
C64----COMPUTE STREAM LEAKAGE IF STREAM DEPTH WAS NOT COMPUTED
C          USING EITHER BISECTION OR NEWTON METHOD.
C      Revised dep 3/31/2005
            IF(ISKIP.EQ.0) THEN
              CSTR=STRLEAK*WIDTH/SBDTHK
              IF(FLOWC.LE.0.0D0) THEN
                HSTR=STRM(3,L)
                IF(H.LT.HSTR) THEN
                  FLOBOT=0.0D0
                ELSE
                  FLOBOT=CSTR*(HSTR-H)
                END IF
              ELSE
                IF(H.LT.SBOT)THEN
                  FLOBOT=CSTR*(HSTR-SBOT)
                ELSE
                  FLOBOT=CSTR*(HSTR-H)
                END IF
              END IF
            ELSE
                FLOBOT=0.0D0
            END IF
        END IF
C65-----STREAMFLOW OUT EQUALS STREAMFLOW IN MINUS LEAKAGE.
C       Revised dep 3/31/2005
            FLOWOT=FLOWC-FLOBOT
            IF(FLOWOT.LT.0.0D0) THEN
              FLOWOT=0.0D0
              FLOBOT=FLOWC
              FLWMPT=0.5*FLOWC
              DEPTH=0.0D0
            END IF
C
C66-----STORE OUTFLOW FROM LAST REACH IN LAST SEGMENT IN STRIN
C          LIST FOR LAKE PACKAGE.
          IF(IUNITLAK.GT.0) THEN
            IF((L.EQ.NSTRM).AND.(ISTSG.EQ.NSS)) STRIN(ISTSG)=FLOWOT
          END IF
C
C67-----STORE STREAM INFLOW, OUTFLOW, LEAKAGE, STAGE, AND STREAMBED
C          CONDUCTANCE FOR EACH REACH.
         STRM(9,L)=FLOWOT
         STRM(10,L)=FLOWIN
         STRM(11,L)=FLOBOT
         STRM(15,L)=HSTR
         STRM(16,L)=CSTR
         IF(ICALC.GE.1)STRM(7,L)=DEPTH
         IF(ICALC.GE.2)STRM(5,L)=WIDTH
C
C68-----STORE FLOWS NEEDED FOR SENSITIVITIES - ERB
      SFRQ(1,L)=FLWMPT
      SFRQ(2,L)=FLOWC
      SFRQ(3,L)=FLOBOT
      SFRQ(5,L)=FLOWIN
C
C69-----ADD TERMS TO RHS AND HCOF IF FLOBOT IS NOT ZERO.
         IF(DABS(FLOBOT).GT.0.0D0) THEN
C
C70-----IF HEAD > BOTTOM THEN ADD TERMS TO RHS AND HCOF.
            IF(HNEW(IC,IR,IL).GT.SBOT) THEN
              IF(FLOBOT.LT.FLOWC) THEN
C71-----HEAD-DEPENDENT SEEPAGE.
                 RHS(IC,IR,IL)=RHS(IC,IR,IL)-(CSTR*HSTR)
                 HCOF(IC,IR,IL)=HCOF(IC,IR,IL)-CSTR
              ELSE
C72-----CONSTANT SEEPAGE LIMITED BY STREAMFLOW OR STREAMBED
C         CONDUCTANCE IN REACH.
                RHS(IC,IR,IL)=RHS(IC,IR,IL)-FLOBOT
              END IF
C
C73-----IF HEAD < BOTTOM THEN ADD TERM ONLY TO RHS.
            ELSE
               RHS(IC,IR,IL)=RHS(IC,IR,IL)-FLOBOT
            END IF
         END IF
      L=L+1
      END DO
C
C74-----RETURN.
      RETURN
      END
C
C------SUBROUTINE GWF1SFR1BD
C
      SUBROUTINE GWF1SFR1BD(STRM,ISTRM,HNEW,IBOUND,NSTRM,NCOL,NROW,
     1                  NLAY,NSS,SEG,ISEG,IOTSG,XSEC,IDIVAR,CONST,
     2                  MAXPTS,QSTAGE,SGOTFLW,DVRSFLW,NLAKESAR,
     3                  STGOLD,STGNEW,VOL,STRIN,STROUT,THETA,DELT,
     4                  KSTP,KPER,VBVL,VBNM,MSUM,ISTCB1,ISTCB2,ICBCFL,
     5                  BUFF,IOUT,IPTFLG,I15,IUNITGAGE,IGGLST,NUMGAGE,
     6                  PERTIM,TOTIM,SFRQ,NSEGDIM,IUNITLAK,DLEAK)
C
C     VERSION 1.4:CONNECTED TO LAK3 PACKAGE AND MODFLOW-GWT-- Mar. 2005
C
C     *****************************************************************
C     CALCULATE VOLUMETRIC GROUND-WATER BUDGET FOR STREAMS AND SUM
C     STREAMFLOWS IN MODELED AREA
C     *****************************************************************
C
C     SPECIFICATIONS:
C     -----------------------------------------------------------------
C
      CHARACTER*16 VBNM(MSUM),TEXT,STRTXT
      DOUBLE PRECISION HNEW,H,HSTR,SBOT,CSTR,RATIN,RATOUT,
     1                 FLOWIN,FLOBOT,FLOW,FLOWOT,DIF,SBDTHK,
     2                 UPFLW,TRBFLW,WIDTH,WETPERM,RUNOF,PRECIP,
     3                 ETSTR,DLKSTR,SLOPE,FLWLW,FLWHI,STGLW,
     4                 STGHI,DFLWLW,DFLWHI,DSTGLW,DSTGHI,DLGLAK,
     5                 DLGSLP,DLGFLW,CDPTH,FDPTH,HDIFF,GRAD,DEPTH
      DIMENSION STRM(18,NSTRM),ISTRM(5,NSTRM),
     1          HNEW(NCOL,NROW,NLAY),IBOUND(NCOL,NROW,NLAY),
     2          BUFF(NCOL,NROW,NLAY),SEG(17,NSS),VBVL(4,MSUM),
     3          ISEG(3,NSEGDIM),IOTSG(NSS),XSEC(16,NSS),IDIVAR(2,NSS),
     4          QSTAGE(MAXPTS,NSS),SGOTFLW(NSS),DVRSFLW(NSS),
     5          STGOLD(NLAKESAR),STRIN(NSS),STROUT(NSS),STGNEW(NLAKESAR)
      DIMENSION IGGLST(4,NUMGAGE),VOL(NLAKESAR)
      REAL SFRQ(5,NSTRM)
C
      DATA TEXT /'  STREAM LEAKAGE'/
      DATA STRTXT /'STREAMFLOW OUT  '/
C     -----------------------------------------------------------------
C
C1-----INITIALIZE CELL BY CELL FLOW TERM FLAG (IBD) AND
C       ACCUMULATORS (RATIN AND RATOUT).
      IBD=0
      IBDST=0
      ZERO=0.
      RATIN=ZERO
      RATOUT=ZERO
      IF(ISTCB1.LT.0 .AND. ICBCFL.NE.0) IBD= -1
      IF(ISTCB1.GT.0) IBD=ICBCFL
      IF(ISTCB2.GT.0 .AND. ICBCFL.NE.0) THEN
         IBDST= -1
         IOUT2=ISTCB2
      END IF
      IBDLBL=0
      IBSTLB=0
C
C2-----IF CELL-BY-CELL FLOWS WILL BE SAVED AS A LIST, WRITE HEADER.
      IF(IBD.EQ.2) CALL UBDSV2(KSTP,KPER,TEXT,ISTCB1,NCOL,NROW,NLAY,
     1                  NSTRM,IOUT,DELT,PERTIM,TOTIM,IBOUND)
C
C3-----CLEAR BUFFERS.
      DO 5 IL=1,NLAY
      DO 5 IR=1,NROW
      DO 5 IC=1,NCOL
      BUFF(IC,IR,IL)=ZERO
    5 CONTINUE
C
C4-----IF THERE ARE STREAMS.  INITIALIZE SEGMENT INFLOWS AND OUTFLOWS
C       TO ZERO FOR LAKE PACKAGE.
      IPRVSG=-1
      I=1
      DO WHILE (I.LE.NSS)
         IF(IUNITLAK.GT.0)THEN
          STRIN(I)=0.0
          STROUT(I)=0.0
         END IF
        I=I+1
      END DO
C
C5-----DETERMINE LAYER, ROW, COLUMN OF EACH REACH.
      DO L=1,NSTRM
        LL=L-1
        IL=ISTRM(1,L)
        IR=ISTRM(2,L)
        IC=ISTRM(3,L)
C
C6-----DETERMINE STREAM SEGMENT AND REACH NUMBER.
        ISTSG=ISTRM(4,L)
        NREACH=ISTRM(5,L)
        ICALC=ISEG(1,ISTSG)
        IF(ICALC.EQ.1.OR.ICALC.EQ.2) SLOPE=STRM(2,L)
        IF(ICALC.EQ.4) NSTRPTS=ISEG(2,ISTSG)
C
C7------SET FLOWIN EQUAL TO STREAM SEGMENT INFLOW IF FIRST REACH.
      IF(NREACH.EQ.1) THEN
          IF(ISEG(3,ISTSG).EQ.5) FLOWIN=SEG(2,ISTSG)
C
C8------STORE OUTFLOW FROM PREVIOUS SEGMENT IN SGOTFLW LIST AND IN
C         STRIN FOR LAKE PACKAGE.
          IF(ISTSG.GT.1)THEN
            IPRVSG = ISTRM(4,LL)
            SGOTFLW(IPRVSG)=STRM(9,LL)
            IF(IUNITLAK.GT.0)STRIN(IPRVSG)=STRM(9,LL)
          END IF
C
C9-------COMPUTE INFLOW OF A STREAM SEGMENT EMANATING FROM A LAKE.
          IF((IUNITLAK.GT.0).AND.(IDIVAR(1,ISTSG).LT.0)) THEN
             LK=IABS(IDIVAR(1,ISTSG))
             STGON=(1.0-THETA)*STGOLD(LK)+
     1              THETA*STGNEW(LK)
             DLKSTR=STGON-SEG(8,ISTSG)
              IF (SEG(2,ISTSG).GT.0.0.AND.VOL(LK).GT.0.0) THEN
                 FLOWIN=SEG(2,ISTSG)
                 STROUT(ISTSG)=FLOWIN
              ELSE IF (SEG(2,ISTSG).LT.0.0) THEN
                 WRITE (IOUT,10) ISTSG
   10            FORMAT (/5X,'*** WARNING *** NEGATIVE LAKE DIVERSION ',
     1                'NOT ALLOWED; SEG = ',I6,
     2                /10X,'SFR1BD CODE WILL ASSUME FLOW = 0.0'/)
                 SEG(2,ISTSG)=0.0
                 FLOWIN=SEG(2,ISTSG)
                 STROUT(ISTSG)=FLOWIN
              ELSE
C
C10----SPECIFIED FLOW FROM LAKE IS ZERO AND ICALC IS ZERO.
                IF (ICALC.EQ.0) THEN
                  FLOWIN=0.0D0
C
C11----FLOW FROM LAKE COMPUTED USING MANNINGS FORMULA AND ASSUMING A
C         WIDE RECTANGULAR CHANNEL.
                ELSE IF (DLKSTR.GT.0.0.AND.ICALC.EQ.1) THEN
                  FLOWIN=(CONST/SEG(16,ISTSG))*SEG(9,ISTSG)*
     1                    ((DLKSTR)**(5.D0/3.D0))*DSQRT(SLOPE)
C
C12----FLOW FROM LAKE COMPUTED USING MANNINGS FORMULA AND EIGHT POINT
C         CROSS SECTIONAL AREA.
                ELSE IF(DLKSTR.GT.0.0.AND.ICALC.EQ.2) THEN
                  CALL GWF1SFR1FLW(DLKSTR,XSEC,CONST,ISTSG,NSS,
     1                SEG(16,ISTSG),SEG(17,ISTSG),SLOPE,WETPERM,
     2                FLOWIN,WIDTH)
C
C13----FLOW FROM LAKE COMPUTED USING FORMULA--
C         Q=(DEPTH/CDPTH)**(1/FDPTH).
                ELSE IF(DLKSTR.GT.0.0.AND.ICALC.EQ.3) THEN
                  CDPTH=SEG(9,ISTSG)
                  FDPTH=SEG(10,ISTSG)
                  FLOWIN=(DLKSTR/CDPTH)**(1/FDPTH)
C
C14----FLOW FROM LAKE COMPUTED USING TABULATED VALUES.
                ELSE IF(DLKSTR.GT.0.0.AND.ICALC.EQ.4) THEN
                   NSTRPTS=ISEG(2,ISTSG)
                   FLWLW=QSTAGE(1,ISTSG)
                   STGLW=QSTAGE(1+NSTRPTS,ISTSG)
                   FLWHI=QSTAGE(NSTRPTS,ISTSG)
                   STGHI=QSTAGE(2*NSTRPTS,ISTSG)
                     IF(DLKSTR.LE.STGLW) THEN
                       FLOWIN=(FLWLW/STGLW)*DLKSTR
                     ELSE IF(DLKSTR.GT.STGLW) THEN
                       ISTP=2+NSTRPTS
                       STGHI=QSTAGE(ISTP,ISTSG)
                         DO WHILE(DLKSTR.GT.STGHI.AND.
     1                             ISTP.LT.(2*NSTRPTS))
                           ISTP=ISTP+1
                           STGHI=QSTAGE(ISTP,ISTSG)
                         END DO
                     END IF
                     IF(DLKSTR.LE.STGHI) THEN
                       ISTGLW=ISTP-1
                       IFLWHI=ISTP-NSTRPTS
                       IFLWLW=IFLWHI-1
                       FLWLW=QSTAGE(IFLWLW,ISTSG)
                       STGLW=QSTAGE(ISTGLW,ISTSG)
                       FLWHI=QSTAGE(IFLWHI,ISTSG)
                     ELSE IF(DLKSTR.GT.STGHI) THEN
                       WRITE(IOUT,2)DLKSTR,IDIVAR(1,ISTSG),STGHI
    2                  FORMAT(/1X,'NOTE-- WHEN ICALC IS 4, COMPUTED ',
     1                   'DEPTH OF ',1PE10.3,' FOR LAKE ',I6,' IS ',
     2                   'GREATER THAN THE GREATEST DEPTH IN RATING ',
     3                   'TABLE',1PE10.3,//1X,'WILL ASSUME A CONSTANT',
     4                   ' RELATION ABOVE THE GREATEST DEPTH'//)
                       FLWLW=QSTAGE(NSTRPTS-1,ISTSG)
                       STGLW=QSTAGE((2*NSTRPTS)-1,ISTSG)
                     END IF
                     DFLWLW=DLOG10(FLWLW)
                     DSTGLW=DLOG10(STGLW)
                     DFLWHI=DLOG10(FLWHI)
                     DSTGHI=DLOG10(STGHI)
                     DLGLAK=DLOG10(DLKSTR)-DSTGLW
                     DLGSLP=(DFLWHI-DFLWLW)/(DSTGHI-DSTGLW)
                     DLGFLW=DFLWLW+(DLGSLP*DLGLAK)
                     FLOWIN=10.D0**DLGFLW
                     STROUT(ISTSG)=FLOWIN
                ELSE IF (DLKSTR.LT.0.0D0.AND.ICALC.GT.0) THEN
                  FLOWIN=0.0D0
                END IF
               STROUT(ISTSG)=FLOWIN
              END IF
          END IF
C
C15-----CHECK IF UPSTREAM SEGMENT GETS DIVERTED AND DETERMINE
C        SEGMENT NUMBER OF DIVERSION.CHANGES MADE BY CSTILLERY TO
C        ALLOW FOR MULTIPLE DIVERSIONS AT END OF A STREAM SEGMENT.
          IF(ISTSG.GT.1) THEN
            IPRVSG = ISTRM(4,LL)                                !CSTILLERY
            KSS=1                                               !CSTILLERY
            DO WHILE(KSS.LE.NSS)                                !CSTILLERY
              IDIVSEG=0
              IUPSEG = 0
              DO WHILE(IPRVSG.NE.IUPSEG)                        !CSTILLERY
                IUPSEG=IDIVAR(1,KSS)
                IF(IUPSEG.EQ.IPRVSG) IDIVSEG=KSS
                KSS=KSS+1
                IF (KSS.GT.NSS) IPRVSG=IUPSEG                   !CSTILLERY
              END DO
              IF(IDIVSEG.GT.0) THEN
C
C16-----DETERMINE DIVERSION AND SUBTRACT IT FROM
C         FLOW AT END OF UPSTREAM SEGMENT.
                 DVRSFLW(IDIVSEG)=SEG(2,IDIVSEG)
                 UPFLW=SGOTFLW(IUPSEG)
                 IPRIOR=IDIVAR(2,IDIVSEG)
C17-----IF IPRIOR IS ZERO THEN FLOW DIVERTED CAN BE ALL OF
C         STREAMFLOW UP TO SPECIFIED FLOW.
                   IF (IPRIOR.EQ.0) THEN
                      DIF=UPFLW-DVRSFLW(IDIVSEG)
                      IF (DIF.GE.0.0) THEN
                         SGOTFLW(IUPSEG)=DIF
                      ELSE
                         SGOTFLW(IUPSEG)=0.0
                         DVRSFLW(IDIVSEG)=UPFLW
                      END IF
C
C18-----IF IPRIOR IS -1 THEN FLOW DIVERTED ONLY IF SPECIFIED FLOW
C         AVAILABLE OTHERWISE NO FLOW DIVERTED.
                   ELSE IF (IPRIOR.EQ.-1) THEN
                      DIF=UPFLW-DVRSFLW(IDIVSEG)
                      IF (DIF.GE.0.0) THEN
                         SGOTFLW(IUPSEG)=DIF
                      ELSE
                         DVRSFLW(IDIVSEG)=0.0
                      END IF
C
C19-----IF IPRIOR IS -2 THEN FLOW DIVERTED IS PERCENTAGE OF
C         AVAILABLE STREAMFLOW.
                   ELSE IF (IPRIOR.EQ.-2) THEN
                      PRCNT=DVRSFLW(IDIVSEG)
                      DVRSFLW(IDIVSEG)=UPFLW*PRCNT
                      SGOTFLW(IUPSEG)=UPFLW-DVRSFLW(IDIVSEG)
C
C20-----IF IPRIOR IS -3 THEN FLOW DIVERTED ONLY WHEN STREAMLFOW
C         EXCEEDS SPECIFIED FLOW (FLOOD CONTROL DIVERSION).
                   ELSE IF (IPRIOR.EQ.-3) THEN
                      IF (UPFLW.GT.DVRSFLW(IDIVSEG)) THEN
                         DVRSFLW(IDIVSEG)=UPFLW-SEG(2,IDIVSEG)
                         SGOTFLW(IUPSEG)=SEG(2,IDIVSEG)
                      ELSE
                         DVRSFLW(IDIVSEG)=0.0
                      END IF
                   END IF
               END IF
           END DO                                               !CSTILLERY
          END IF
C
C21-----SET FLOW INTO DIVERSION IF SEGMENT IS DIVERSION.
          IF(ISTSG.GT.1.AND.ISEG(3,ISTSG).EQ.6) THEN
             IF(IDIVAR(1,ISTSG).GT.0)FLOWIN=DVRSFLW(ISTSG)
          END IF
C
C22----SUM TRIBUTARY OUTFLOW AND USE AS INFLOW INTO DOWNSTREAM SEGMENT.
          IF(ISTSG.GT.1.AND.ISEG(3,ISTSG).EQ.7) THEN
            ITRIB=1
            FLOWIN=0.0
            DO WHILE (ITRIB.LE.NSS)
                IF(ISTSG.EQ.IOTSG(ITRIB)) THEN
                  TRBFLW=SGOTFLW(ITRIB)
                  FLOWIN=FLOWIN+TRBFLW
                END IF
              ITRIB=ITRIB+1
            END DO
           FLOWIN=FLOWIN+SEG(2,ISTSG)
C
C23-----CHECK IF "FLOW" IS WITHDRAWAL, THAT WATER IS AVAILABLE.
             IF (FLOWIN.LT.0.0D0) THEN
               FLOWIN=0.0D0
               WRITE (IOUT,13) ISTSG
   13          FORMAT (//2X,'*** WARNING *** FLOW INTO DIVERSIONARY ',
     1              'STREAM SEGMENT No. ',I6,' WAS NEGATIVE; ',
     2              'FLOWIN RE-SET = 0.0'/)
             END IF
           END IF
C
C24-----IF REACH >1, SET INFLOW EQUAL TO OUTFLOW FROM UPSTREAM REACH.
        ELSE IF (NREACH.GT.1) THEN
          FLOWIN=STRM(9,LL)
        END IF
C
C25-----SEARCH FOR UPPER MOST ACTIVE CELL IN STREAM REACH.
           ILAY=IL

CERB--Changed to handle case of no active cell in stack of cells 3/25/05
!             DO WHILE(IBOUND(IC,IR,ILAY).EQ.0.AND.ILAY.LE.NLAY)
!               ILAY=ILAY+1
!             END DO
           TOPCELL: DO WHILE(ILAY.LE.NLAY)
             IF (IBOUND(IC,IR,ILAY).EQ.0) THEN
               ILAY=ILAY+1
             ELSE
               EXIT TOPCELL
             ENDIF
           END DO TOPCELL
CERB end of change
C
C26----DETERMINE LEAKAGE THROUGH STREAMBED.
                DEPTH=STRM(7,L)
                IF(ICALC.EQ.0) DEPTH=STRM(15,L)-STRM(3,L)
                HSTR=STRM(15,L)
                CSTR=STRM(16,L)
                WIDTH=STRM(5,L)
                SBOT=STRM(4,L)
                SBDTHK=STRM(8,L)

C    Moved from before C26 to follow C26 and placed H below C27.
C      dep 3/31/2005
           IF (ILAY.LE.NLAY)IL=ILAY
           IF(ILAY.LE.NLAY.AND.IBOUND(IC,IR,IL).GT.0) THEN
C
C27------COMPUTE HEAD DIFFERENCE ACROSS STREAMBED.
                H=HNEW(IC,IR,IL)
                  IF(H.LT.SBOT) THEN
                    HDIFF=HSTR-SBOT
                    GRAD=(HDIFF)/SBDTHK
                  ELSE
                    HDIFF=HSTR-H
                    GRAD=(HDIFF)/SBDTHK
                  END IF
C
C28------COMPUTE LEAKAGE ACROSS STREAMBED.
                   FLOBOT=CSTR*(HDIFF)
C
C29-----STREAMFLOW OUT EQUALS STREAMFLOW IN MINUS LEAKAGE.
C      Initialized GRAD to zero when reach overlies inactive cells
C       dep 3/31/2005
           ELSE IF (IBOUND(IC,IR,IL).LE.0) THEN
             FLOBOT=0.0D0
             GRAD=0.0D0 ! ERB 4/1/05
             HDIFF=0.0D0 ! ERB 4/1/05
           END IF
C
C30----COMPUTE FLOW IN STREAM CHANNEL AND SET LEAKAGE EQUAL TO FLOW
C        IF LEAKAGE MORE THAN FLOW.
C     Set DEPTH to 0 when ICALC is zero and FLOW is zero. dep 3/31/2005
           IF(ICALC.LE.1) THEN
              RUNOF=STRM(12,L)
              PRECIP=STRM(14,L)
              ETSTR=STRM(13,L)
           ELSE IF(ICALC.GE.2.AND.ICALC.LE.4) THEN
              RUNOF=STRM(12,L)
              PRECIP=STRM(14,L)*WIDTH
              ETSTR=STRM(13,L)*WIDTH
           END IF
           FLOW=FLOWIN+RUNOF+PRECIP-ETSTR
           IF(FLOW.LE.0.0D0.AND.FLOBOT.GE.0.0D0) THEN
             FLOW=0.0D0
             IF(ICALC.EQ.0)DEPTH=0.0D0
             IF(FLOWIN+RUNOF+PRECIP.GT.0.0D0)THEN
               ETSTR=FLOWIN+RUNOF+PRECIP
               FLOBOT=0.0D0
             ELSE
               ETSTR=0.0D0
             END IF
           ELSE IF(FLOW.LE.0.0D0.AND.FLOBOT.LT.0.0D0) THEN
             IF(ETSTR.GE.-FLOBOT)ETSTR=-FLOBOT
             FLOW=FLOWIN+RUNOF+PRECIP-ETSTR
             IF(ICALC.EQ.0)DEPTH=0.0D0
           END IF
           IF(FLOBOT.GE.FLOW) THEN
              FLOBOT=FLOW
              IF(ICALC.EQ.0)DEPTH=0.0D0
           END IF
C         FLWMPT=FLOWIN+0.5D0*(RUNOF+PRECIP-ETSTR-FLOBOT)
         FLOWOT=FLOW-FLOBOT

C
C31-----STORE OUTFLOW FROM LAST REACH IN LAST SEGMENT IN STRIN
C          LIST FOR LAKE PACKAGE.
         IF(IUNITLAK.GT.0) THEN
           IF((L.EQ.NSTRM).AND.(ISTSG.EQ.NSS)) STRIN(ISTSG)=FLOWOT
         END IF
C
C32-----STORE STREAM INFLOW, OUTFLOW, AND LEAKAGE FOR EACH REACH.
         STRM(9,L)=FLOWOT
         STRM(10,L)=FLOWIN
         STRM(11,L)=FLOBOT
         STRM(17,L)=HDIFF
         STRM(18,L)=GRAD
C
C33------PRINT STREAMFLOWS AND RATES FOR EACH REACH TO MAIN LIST
C         IF REQUESTED (WHEN ISTCB1<0).
         IF(IBD.LT.0.AND.IPTFLG.LE.0) THEN
            IF(IBDLBL.EQ.0.) WRITE (IOUT,16) TEXT,KPER,KSTP
   16         FORMAT(1X,///1X,A,'   PERIOD ',I4,'   STEP ',I3,//,1X,
     1        'LAYER',1X,'ROW',1X,'COL.',1X,'STREAM',2X,'RCH.',
     2        2X,'FLOW INTO',4X,'FLOW TO',2X,'FLOW OUT OF',2X,
     3        'OVRLND.',3X,'DIRECT',4X,'STREAM',4X,'STREAM',4X,
     4        'STREAM',4X,'STREAM',2X,'STREAMBED',2X,'STREAMBED',
     5        /16X,'SEG.NO.',2X,'NO.',2X,'STRM. RCH.',3X,'AQUIFER',
     6        3X,'STRM. ','RCH.',2X,'RUNOFF',4X,'PRECIP',6X,'ET',
     7        7X,'HEAD',6X,'DEPTH',5X,'WIDTH',2X,'CONDCTNC.',
     8        2X,' GRADIENT'/)
            WRITE(IOUT,21) IL,IR,IC,ISTRM(4,L),ISTRM(5,L),
     1           STRM(10,L),STRM(11,L),STRM(9,L),SNGL(RUNOF),
     2           SNGL(PRECIP),SNGL(ETSTR),STRM(15,L),DEPTH,
     3           STRM(5,L),STRM(16,L),GRAD
   21       FORMAT(1X,I3,I5,I5,2I6,4X,1PE9.3,2X,E10.3,1X,E10.3,1X,
     1               E9.2,7(1X,E9.2))
            IBDLBL=1
         END IF
C
C34------PRINT STREAMFLOWS AND RATES FOR EACH REACH TO STREAM LIST
C         IF REQUESTED (WHEN ISTCB2>0).
         IF(IBDST.LT.0.AND.IPTFLG.LE.0) THEN
            IF(IBSTLB.EQ.0) WRITE (IOUT2,16) STRTXT,KPER,KSTP
            WRITE(IOUT2,21) IL,IR,IC,ISTRM(4,L),ISTRM(5,L),
     1           STRM(10,L),STRM(11,L),STRM(9,L),SNGL(RUNOF),
     2           SNGL(PRECIP),SNGL(ETSTR),STRM(15,L),DEPTH,
     3           STRM(5,L),STRM(16,L),GRAD
            IBSTLB=1
         END IF
C
C35------ADD RATES TO BUFFERS.
         BUFF(IC,IR,IL)=BUFF(IC,IR,IL)+FLOBOT
C
C36------SUBTRACT FLOBOT FROM RATOUT IF GROUND WATER DISCHARGING
C          TO STREAM REACH.
         IF(FLOBOT.LT.0.0D0) RATOUT=RATOUT-FLOBOT
C
C37------ADD FLOBOT TO RATIN IF STREAM RECHARGING GROUND WATER.
         IF(FLOBOT.GT.0.0D0) RATIN=RATIN+FLOBOT
C
C38------IF IBD=2, SAVE FLOW TO AND FROM GROUND WATER IN A LIST FILE.
         IF(IBD.EQ.2) CALL UBDSVA(ISTCB1,NCOL,NROW,IC,IR,IL,
     1      SNGL(FLOBOT),IBOUND,NLAY)
C
      END DO
C
C39------IF IBD=1, SAVE FLOW TO AND FROM GROUND WATER AS A 3-D ARRAY.
         IF(IBD.EQ.1)CALL UBUDSV(KSTP,KPER,TEXT,ISTCB1,BUFF,NCOL,
     1      NROW,NLAY,IOUT)
C
C40------MOVE RATES, VOLUMES AND LABELS INTO ARRAYS FOR PRINTING.
         RIN=RATIN
         ROUT=RATOUT
         VBVL(3,MSUM)=RIN
         VBVL(4,MSUM)=ROUT
         VBVL(1,MSUM)=VBVL(1,MSUM)+RIN*DELT
         VBVL(2,MSUM)=VBVL(2,MSUM)+ROUT*DELT
         VBNM(MSUM)=TEXT
C
C41------INCREMENT BUDGET TERM COUNTER.
         MSUM=MSUM+1
C
C42------RECORD STREAM GAGING STATION DATA (IF SOLUTE TRANSPORT NOT ACTIVE)
         IF (I15.LE.0) THEN
          NDUM=1
          IF(IUNITGAGE.GT.0) CALL SGWF1GAG5SO(IGGLST,NUMGAGE,I15,STRM,
     1                 ISEG,NSEGDIM,NSTRM,TOTIM,NDUM,BUFF,SFRQ,NSS,
     2                 SEG,SGOTFLW,IDIVAR)
         END IF
C
       IF(IBD.LT.0.AND.IPTFLG.LE.0) WRITE (IOUT,22)
   22     FORMAT (//)
C
C43-----RETURN.
      RETURN
      END
C
C------SUBROUTINE GWF1SFR1DPTH
C
      SUBROUTINE GWF1SFR1DPTH(FLOW,XSEC,SLOPE,CONST,ISTSG,NREACH,NSS,
     1                    ROUGHCH,ROUGHBNK,WETPERM,DEPTH,ITSTR,TOTWDTH,
     2                    IOUT,IPRNDPTH)
C     VERSION 1.4:CONNECTED TO LAK3 PACKAGE AND MODFLOW-GWT-- AUG. 2003
C
C     ******************************************************************
C     COMPUTES STREAM DEPTH GIVEN FLOW USING 8-POINT CROSS SECTION.
C     ******************************************************************
C
C     SPECIFICATIONS:
C     ------------------------------------------------------------------
C
      DOUBLE PRECISION FLOW,FLOW1,FLOW2,SLOPE,FLOW3,WETPERM,DEPTH,
     1               TOTWDTH,Y0,YMIN,XNUM,DNOM,STAGE,DEPTH1,DEPTH2,
     2               DEPTH3,F1,F2,F3,ERR1,ERR2,ERR3

     3
      DIMENSION XSEC(16,NSS)
C
C1------INITIALIZE VARIABLES TO ZERO.
      TOTWDTH=0.0D0
      WETPERM=0.0D0
      IF(IPRNDPTH.EQ.1) THEN
      IXX=IPRNDPTH
      END IF
C
C3------FIND LOWEST POINT IN CHANNEL.
      YMIN=XSEC(9,ISTSG)
      I=9
      DO WHILE (I.LE.16)
       Y0=XSEC(I,ISTSG)
       YMIN=DMIN1(YMIN,Y0)
       I=I+1
      END DO
C
C4------ESTIMATE INITIAL DEPTH ASSUMING WIDE RECTANGULAR CHANNEL
      DEPTH1=0.0D0
      XNUM=FLOW*ROUGHCH
      DNOM=CONST*(XSEC(6,ISTSG)-XSEC(3,ISTSG))*SQRT(SLOPE)
      IF(DNOM.GT.0.0D0)DEPTH1=(XNUM/DNOM)**0.6
      IF (DEPTH1.GT.0.0D0) THEN
        STAGE=DEPTH1+YMIN
        FLOW1=0.0D0
        CALL GWF1SFR1FLW(STAGE,XSEC,CONST,ISTSG,NSS,ROUGHCH,ROUGHBNK,
     1               SLOPE,WETPERM,FLOW1,TOTWDTH)
        F1=FLOW-FLOW1
        DEPTH2=1.1*DEPTH1
        STAGE=DEPTH2+YMIN
        FLOW2=0.0D0
        CALL GWF1SFR1FLW(STAGE,XSEC,CONST,ISTSG,NSS,ROUGHCH,ROUGHBNK,
     1               SLOPE,WETPERM,FLOW2,TOTWDTH)
        F2=FLOW-FLOW2
C
C5------ESTIMATE NEW DEPTH USING EITHER BISECTION OR SECANT METHOD FOR
C                SOLVING ROOTS.
        DEPTH3=0.0D0
          IF((F1*F2).LT.0.0D0.AND.((DEPTH1.GT.2.*DEPTH2).OR.
     1       (DEPTH2.GT.(2.*DEPTH1))))THEN
C
C6------USE BISECTION METHOD
           DEPTH3 = (DEPTH1+DEPTH2)*0.5
C
C7------USE SECANT METHOD
          ELSE
           DEPTH3=DEPTH2-(F2*(DEPTH2-DEPTH1)/(F2-F1))
          END IF
        ERR1=DABS(DEPTH3-DEPTH1)
        ERR2=DABS(DEPTH3-DEPTH2)
        IF(ERR1.LT.0.000001.AND.ERR2.LT.0.000001) THEN
          DEPTH3=(DEPTH1+DEPTH2)/2.0
C
C8------CONTINUE RECALCULATING DEPTH3 UNTIL ERROR LESS THAN 0.000001
C         OR 100 ITERATIONS HAVE BEEN REACHED.
        ELSE
          IFLG=1
          ITSTR=1
          DO WHILE(IFLG.GT.0)
            IF(F1*F2.LT.0.0D0.AND.(DEPTH1.GT.2.0*DEPTH2.OR.
     1         DEPTH2.GT.2.0*DEPTH1)) THEN
               DEPTH3=(DEPTH1+DEPTH2)/2.0
            ELSE IF(DABS(F2-F1).GT.0.0D0) THEN
                    DEPTH3=DEPTH2-(F2*(DEPTH2-DEPTH1)/(F2-F1))
            ELSE IF(DABS(F2-F1).EQ.0.0D0) THEN
               DEPTH3=(DEPTH1+DEPTH2)/2.0
            END IF
            ERR1=DABS(DEPTH3-DEPTH1)
            ERR2=DABS(DEPTH3-DEPTH2)
            ERR3=DABS(F2-F1)
            IF((ERR1.LT.0.000001.OR.ERR2.LT.0.000001).AND.
     1         ITSTR.GT.2) IFLG=0
            IF(ERR3.LT.0.0001.AND.ITSTR.GT.2)IFLG=0
             STAGE=DEPTH3+YMIN
             CALL GWF1SFR1FLW(STAGE,XSEC,CONST,ISTSG,NSS,ROUGHCH,
     1                    ROUGHBNK,SLOPE,WETPERM,FLOW3,TOTWDTH)
             F3=FLOW-FLOW3
               IF(F2*F3.LT.0.0D0)THEN
C
C9------ROOT IS BETWEEN DEPTH2 AND DEPTH3
                  IF(F1*F2.LT.0.0D0) THEN
C
C10-----ROOT IS BETWEEN DEPTH1 AND DEPTH2
                    DEPTH1=DEPTH3
                    F1=F3
                  ELSE
C
C11-----DEPTH1 AND DEPTH2 ON SAME SIDE OF ROOT;
C          REPLACE WITH FARTHER ROOT.
                     IF(DABS(F1).GT.DABS(F2)) THEN
                        DEPTH1=DEPTH2
                        F1=F2
                     END IF
                   DEPTH2=DEPTH3
                   F2=F3
                  END IF
               ELSE
C
C12-----DEPTH2 AND DEPTH3 ARE ON THE SAME SIDE OF ROOT
                  IF(F1*F2.LT.0.0D0)THEN
C
C13-----ROOT IS BETWEEN DEPTH1 AND DEPTH2
                     DEPTH2=DEPTH3
                     F2=F3
                  ELSE
C
C14-----DEPTH1,2 AND 3 ARE ON SAME SIDE OF ROOT;
C          REPLACE WITH NEAREST VALUE.
                       IF(DABS(F1).GT.DABS(F2))THEN
                         DEPTH1=DEPTH2
                         F1=F2
                       END IF
                     DEPTH2=DEPTH3
                     F2=F3
                   END IF
                END IF
           ITSTR=ITSTR+1
             IF(IPRNDPTH.EQ.1) THEN
               WRITE(IOUT,704)ITSTR,IFLG,FLOW,DEPTH1,DEPTH2,DEPTH3,F1,
     1                     F2,F3
  704          FORMAT(1X/,'ITSTR,IFLG,FLOW,DEPTH1,DEPTH2,DEPTH3,F1,F2,',
     1                    ',F3 ',2I5,7(2X,D15.6))
             END IF
C
C15-----PRINT WARNING MESSAGE IF SECANT METHOD FAILED TO FIND A DEPTH.
             IF(ITSTR.GT.100)THEN
                IFLG=0
               WRITE(IOUT,1)ISTSG,NREACH,DEPTH3,DEPTH1,DEPTH2
    1          FORMAT(1X/,'SECANT METHOD FAILED TO FIND SOLUTION FOR ',
     1               'STREAM SEGMENT ',I5,' REACH ',I5,'ESTIMATED ',
     2               'DEPTH IS ',D15.6,'AND BOUNDS ARE ',2(2X,D15.6))
             END IF
           END DO
         END IF
C
C16-----CALCULATE WETTED PERIMETER AND WIDTH FROM
C        FINAL DEPTH.
      DEPTH=DEPTH3
      STAGE=DEPTH+YMIN
      FLOW1=FLOW
      CALL GWF1SFR1FLW(STAGE,XSEC,CONST,ISTSG,NSS,ROUGHCH,ROUGHBNK,
     1             SLOPE,WETPERM,FLOW1,TOTWDTH)
      ELSE
        DEPTH=0.0D0
        WETPERM=0.0D0
        TOTWDTH=0.0D0
        ITSTR=0
      END IF
C
C16----RETURN.
      RETURN
      END
C
C------SUBROUTINE GWF1SFR1FLW
C
      SUBROUTINE GWF1SFR1FLW(DEPTH,XSEC,CONST,ISTSG,NSS,ROUGHCH,
     1                   ROUGHBNK,SLOPE,WETPERM,FLOW,TOTWDTH)
C     VERSION 1.4:CONNECTED TO LAK3 PACKAGE AND MODFLOW-GWT-- AUG. 2003
C
C     *******************************************************************
C     COMPUTES FLOW IN STREAM GIVEN DEPTH USING 8-POINT CROSS SECTION
C     *******************************************************************
C
C     SPECIFICATIONS:
C     -------------------------------------------------------------------
C
      DOUBLE PRECISION FLOW,WETPERM,TOTWDTH,DEPTH,XLEFT,YLEFT,DPTHLEFT,
     1                DPTHRGHT,XRIGHT,YRIGHT,X0,Y0,X1,Y1,WTPRM1,WTPRM2,
     2                WTPRM3,WIDTH1,WIDTH2,WIDTH3,WIDTH,SUBAREA1,
     3             SUBAREA2,SUBAREA3,SUBFLOW1,SUBFLOW2,SUBFLOW3,SLOPE
      DIMENSION XSEC(16,NSS)
C
C1------INITIALIZE VARIABLES TO ZERO.
      TOTWDTH=0.0
      WETPERM=0.0
      SUBAREA1=0.0
      SUBAREA2=0.0
      SUBAREA3=0.0
      SUBFLOW1=0.0
      SUBFLOW2=0.0
      SUBFLOW3=0.0
      WTPRM1=0.0
      WTPRM2=0.0
      WTPRM3=0.0
      WIDTH1=0.0
      WIDTH2=0.0
      WIDTH3=0.0
      FAC=2./3.
      J=1
C
C2------INITIALIZE X AND Y POINTS.
      I=2
      DO WHILE (I.LE.8)
        II=I+8
        X0=XSEC(I-1,ISTSG)
        Y0=XSEC(II-1,ISTSG)
        X1=XSEC(I,ISTSG)
        Y1=XSEC(II,ISTSG)
        IF(DEPTH.GT.Y0) THEN
C
C3------LEFT ENDPOINT IS SUBMERGED.
          XLEFT=X0
          YLEFT=Y0
          DPTHLEFT=DEPTH-YLEFT
            IF(DEPTH.GT.Y1) THEN
C
C4------LEFT AND RIGHT ENDPOINTS ARE SUBMERGED.
                XRIGHT=X1
                YRIGHT=Y1
                DPTHRGHT=DEPTH-YRIGHT
            ELSE
C
C5------LEFT ENDPOINT IS SUBMERGED AND RIGHT IS NOT.
                DPTHRGHT=0.0
                YRIGHT=DEPTH
                XRIGHT=X0+(X1-X0)*(YRIGHT-Y0)/(Y1-Y0)
            END IF
            WIDTH=DABS(XRIGHT-XLEFT)
         ELSE IF(DEPTH.GT.Y1) THEN
C
C6------LEFT ENDPOINT IS ABOVE WATER AND RIGHT IS SUBMERGED.
            DPTHLEFT=0.0
            YLEFT=DEPTH
            XLEFT=X1-(X1-X0)*(Y1-YLEFT)/(Y1-Y0)
            XRIGHT=X1
            YRIGHT=Y1
            DPTHRGHT=DEPTH-YRIGHT
            WIDTH=DABS(XRIGHT-XLEFT)
         ELSE
C
C7------LEFT AND RIGHT ENDPOINTS ARE ABOVE WATER.
            DPTHLEFT=0.0
            DPTHRGHT=0.0
            WIDTH=0.0
         END IF
C
C8------ADD AREA AND WETPERM FOR SUBSECTION OF CHANNEL.
         IF(DPTHLEFT+DPTHRGHT.GT.0.0) THEN
            SUBAREA=0.5*(DPTHLEFT+DPTHRGHT)*WIDTH
            WTPRM=DSQRT(((XLEFT-XRIGHT)*(XLEFT-XRIGHT))+
     1                ((YLEFT-YRIGHT)*(YLEFT-YRIGHT)))
            IF(J.EQ.1) THEN
                      SUBAREA1=SUBAREA1+SUBAREA
                      WTPRM1=WTPRM1+WTPRM
                      WIDTH1=WIDTH1+WIDTH
            END IF
            IF(J.EQ.2) THEN
                      SUBAREA2=SUBAREA2+SUBAREA
                      WTPRM2=WTPRM2+WTPRM
                      WIDTH2=WIDTH2+WIDTH
            END IF
            IF(J.EQ.3) THEN
                      SUBAREA3=SUBAREA3+SUBAREA
                      WTPRM3=WTPRM3+WTPRM
                      WIDTH3=WIDTH3+WIDTH
            END IF
         END IF
C
C9------COMPUTE FLOW FOR EACH SUBSECTION OF CHANNEL.
         IF(I.EQ.3.OR.I.EQ.6.OR.I.EQ.8) THEN
              IF(J.EQ.2) THEN
                 ROUGH=ROUGHCH
              ELSE
                 ROUGH=ROUGHBNK
              END IF
               IF(J.EQ.1.AND.WTPRM1.GT.0.0)THEN
                  R=(SUBAREA1/WTPRM1)**FAC
                  SUBFLOW1=(CONST/ROUGH)*SUBAREA1*R*(SLOPE)**0.5
               ELSE IF(J.EQ.2.AND.WTPRM2.GT.0.0) THEN
                  R=(SUBAREA2/WTPRM2)**FAC
                  SUBFLOW2=(CONST/ROUGH)*SUBAREA2*R*(SLOPE)**0.5
               ELSE IF(J.EQ.3.AND.WTPRM3.GT.0.0) THEN
                  R=(SUBAREA3/WTPRM3)**FAC
                  SUBFLOW3=(CONST/ROUGH)*SUBAREA3*R*(SLOPE)**0.5
               END IF
         J=J+1
         END IF
      I=I+1
      END DO
C
C10------SUM FLOW, WETTED PERIMETER AND WIDTH FOR SUBSECTIONS.
      FLOW=SUBFLOW1+SUBFLOW2+SUBFLOW3
      TOTWDTH=WIDTH1+WIDTH2+WIDTH3
      WETPERM=WTPRM1+WTPRM2+WTPRM3
C
C11------RETURN.
      RETURN
      END
C
C------SUBROUTINE GWF1SFR1TBD
C
      SUBROUTINE GWF1SFR1TBD(FLOW,QSTAGE,DEPTH,WIDTH,NSTRPTS,MAXPTS,
     1                       NSS,NREACH,ISTSG,KKITER,IOUT)
C     VERSION 1.4:CONNECTED TO LAK3 PACKAGE AND MODFLOW-GWT-- AUG. 2003
C
C     *******************************************************************
C     COMPUTES DEPTH AND WIDTH IN STREAM GIVEN FLOW USING RATING TABLES.
C     *******************************************************************
C
C     SPECIFICATIONS:
C     -------------------------------------------------------------------
      DOUBLE PRECISION FLOW,FLWLW,FLWHI,STGLW,STGHI,WTHLW,WTHHI,
     1                 DFLWLW,DFLWHI,DSTGLW,DSTGHI,DWTHLW,DWTHHI,
     2                 DLGFLW,DLGSLS,DLGSLW,DLGSTG,DLGWTH,DEPTH,WIDTH
      DIMENSION QSTAGE(MAXPTS,NSS)
C
C1----DEFINE RANGE OF FLOW, DEPTH, AND WIDTH FROM RATING TABLE.
      FLWLW=QSTAGE(1,ISTSG)
      STGLW=QSTAGE(1+NSTRPTS,ISTSG)
      WTHLW=QSTAGE(1+(2*NSTRPTS),ISTSG)
      FLWHI=QSTAGE(NSTRPTS,ISTSG)
      STGHI=QSTAGE(2*NSTRPTS,ISTSG)
      WTHHI=QSTAGE(3*NSTRPTS,ISTSG)
C
C2----USE A LINEAR INTERPOLATION TO ESTIMATE DEPTH AND WIDTH WHEN
C      FLOW IS LESS THAN LOWEST VALUE IN TABLE.
      IF(FLOW.LE.FLWLW)THEN
        DEPTH=(STGLW/FLWLW)*FLOW
        WIDTH=(WTHLW/FLWLW)*FLOW
C
C3----OTHERWISE USE A LOG INTERPOLATION TO ESTIMATE DEPTH AND WIDTH.
      ELSE IF(FLOW.GT.FLWLW) THEN
C
C4----FIND NEAREST VALUES OF FLOW, DEPTH, AND WIDTH IN TABLE.
        ISTP=2
        FLWHI=QSTAGE(ISTP,ISTSG)
        DO WHILE (FLOW.GT.FLWHI.AND.ISTP.LT.NSTRPTS)
          ISTP=ISTP+1
          FLWHI=QSTAGE(ISTP,ISTSG)
        END DO
        IF(FLOW.LE.FLWHI) THEN
          ISTGHI=ISTP+NSTRPTS
          ISTGLW=ISTGHI-1
          IWTHHI=ISTP+(2*NSTRPTS)
          IWTHLW=IWTHHI-1
          IFLWLW=ISTP-1
          STGHI=QSTAGE(ISTGHI,ISTSG)
          STGLW=QSTAGE(ISTGLW,ISTSG)
          WTHHI=QSTAGE(IWTHHI,ISTSG)
          WTHLW=QSTAGE(IWTHLW,ISTSG)
          FLWLW=QSTAGE(IFLWLW,ISTSG)
        ELSE IF(FLOW.GT.FLWHI) THEN
C
C5----COMPUTED FLOW EXCEEDS HIGHEST FLOW IN TABLE.
          FLWLW=QSTAGE(NSTRPTS-1,ISTSG)
          STGLW=QSTAGE((2*NSTRPTS)-1,ISTSG)
          STGHI=QSTAGE(2*NSTRPTS,ISTSG)
          WTHLW=QSTAGE((3*NSTRPTS)-1,ISTSG)
          WTHHI=QSTAGE((3*NSTRPTS),ISTSG)
        END IF
C
C6----COMPUTE DEPTH AND WIDTH FROM LOG INTERPOLATION.
        DSTGLW=DLOG10(STGLW)
        DSTGHI=DLOG10(STGHI)
        DWTHLW=DLOG10(WTHLW)
        DWTHHI=DLOG10(WTHHI)
        DFLWLW=DLOG10(FLWLW)
        DFLWHI=DLOG10(FLWHI)
        DLGFLW=DLOG10(FLOW)-DFLWLW
        DLGSLS=(DSTGHI-DSTGLW)/(DFLWHI-DFLWLW)
        DLGSLW=(DWTHHI-DWTHLW)/(DFLWHI-DFLWLW)
        DLGSTG=DSTGLW+(DLGSLS*DLGFLW)
        DLGWTH=DWTHLW+(DLGSLW*DLGFLW)
        DEPTH=10.**DLGSTG
        WIDTH=10.**DLGWTH
      END IF
C------RETURN.
      RETURN
      END
C
C------SUBROUTINE GWF1SFR1TBF
C
      SUBROUTINE GWF1SFR1TBF(FLOW,QSTAGE,DEPTH,WIDTH,NSTRPTS,MAXPTS,
     1                       NSS,NREACH,ISTSG,KKITER,IOUT,ITB)
C     VERSION 1.4:CONNECTED TO LAK3 PACKAGE AND MODFLOW-GWT-- AUG. 2003
C
C     *******************************************************************
C     COMPUTES FLOW AND WIDTH IN STREAM GIVEN DEPTH USING RATING TABLES.
C     *******************************************************************
C
C     SPECIFICATIONS:
C     -------------------------------------------------------------------
      DOUBLE PRECISION FLOW,FLWLW,FLWHI,STGLW,STGHI,WTHLW,WTHHI,
     1                 DFLWLW,DFLWHI,DSTGLW,DSTGHI,DWTHLW,DWTHHI,
     2                 DLGFLW,DLGSLF,DLGSLW,DLGSTG,DLGWTH,DEPTH,WIDTH
      DIMENSION QSTAGE(MAXPTS,NSS)
C
C1----DEFINE RANGE OF FLOW, DEPTH, AND WIDTH FROM RATING TABLE.
      FLWLW=QSTAGE(1,ISTSG)
      STGLW=QSTAGE(1+NSTRPTS,ISTSG)
      WTHLW=QSTAGE(1+(2*NSTRPTS),ISTSG)
      FLWHI=QSTAGE(NSTRPTS,ISTSG)
      STGHI=QSTAGE(2*NSTRPTS,ISTSG)
      WTHHI=QSTAGE(3*NSTRPTS,ISTSG)
C
C2----USE A LINEAR INTERPOLATION TO ESTIMATE FLOW AND WIDTH WHEN
C      DEPTH IS LESS THAN LOWEST VALUE IN TABLE.
      IF(DEPTH.LE.STGLW)THEN
        FLOW=(FLWLW/STGLW)*DEPTH
        WIDTH=(WTHLW/FLWLW)*FLOW
C
C3----OTHERWISE USE A LOG INTERPOLATION TO ESTIMATE FLOW AND WIDTH.
      ELSE IF(DEPTH.GT.STGLW) THEN
        ISTP=2
        STGHI=QSTAGE(ISTP+NSTRPTS,ISTSG)
C
C4----FIND NEAREST VALUES OF FLOW, DEPTH, AND WIDTH IN TABLE.
        DO WHILE (DEPTH.GT.STGHI.AND.ISTP.LT.NSTRPTS)
          ISTP=ISTP+1
          STGHI=QSTAGE(ISTP+NSTRPTS,ISTSG)
        END DO
        IF(DEPTH.LE.STGHI) THEN
          ISTGLW=(ISTP-1)+NSTRPTS
          IFLWHI=ISTP
          IFLWLW=ISTP-1
          IWTHHI=ISTP+(2*NSTRPTS)
          IWTHLW=IWTHHI-1
          STGLW=QSTAGE(ISTGLW,ISTSG)
          WTHHI=QSTAGE(IWTHHI,ISTSG)
          WTHLW=QSTAGE(IWTHLW,ISTSG)
          FLWLW=QSTAGE(IFLWLW,ISTSG)
          FLWHI=QSTAGE(IFLWHI,ISTSG)
        ELSE IF(DEPTH.GT.STGHI.AND.ITB.EQ.1) THEN
C
C5----PRINT WARNING IF COMPUTED DEPTH EXCEEDS HIGHEST DEPTH IN TABLE.
           WRITE(IOUT,1)KKITER,ISTSG,NREACH,DEPTH,STGHI
    1      FORMAT(1X/,'FOR MODFLOW ITERATION ',I5,' DEPTH IN SEGMENT ',
     1     I5,' REACH ',I5,' IS ',1PE10.3,' AND IS GREATER THAN ',
     2     'HIGHEST DEPTH LISTED IN RATING TABLE OF ',
     3     1PE10.3,//1X,'ASSUMING SAME RELATION AS ',
     4     'BETWEEN TWO HIGHEST DEPTHS IN TABLE'//)
          FLWLW=QSTAGE(NSTRPTS-1,ISTSG)
          STGLW=QSTAGE((2*NSTRPTS)-1,ISTSG)
          STGHI=QSTAGE(2*NSTRPTS,ISTSG)
          WTHLW=QSTAGE((3*NSTRPTS)-1,ISTSG)
          WTHHI=QSTAGE((3*NSTRPTS),ISTSG)
          FLWLW=QSTAGE(NSTRPTS-1,ISTSG)
          FLWHI=QSTAGE(NSTRPTS,ISTSG)
          STGLW=QSTAGE((2*NSTRPTS)-1,ISTSG)
          STGHI=QSTAGE((2*NSTRPTS),ISTSG)
          WTHLW=QSTAGE((3*NSTRPTS)-1,ISTSG)
          WTHHI=QSTAGE((3*NSTRPTS),ISTSG)
        END IF
C
C6----COMPUTE DEPTH AND WIDTH FROM LOG INTERPOLATION.
        DSTGLW=DLOG10(STGLW)
        DSTGHI=DLOG10(STGHI)
        DWTHLW=DLOG10(WTHLW)
        DWTHHI=DLOG10(WTHHI)
        DFLWLW=DLOG10(FLWLW)
        DFLWHI=DLOG10(FLWHI)
        DLGSTG=DLOG10(DEPTH)-DSTGLW
        DLGSLF=(DFLWHI-DFLWLW)/(DSTGHI-DSTGLW)
        DLGSLW=(DWTHHI-DWTHLW)/(DSTGHI-DSTGLW)
        DLGFLW=DFLWLW+(DLGSLF*DLGSTG)
        DLGWTH=DWTHLW+(DLGSLW*DLGSTG)
        FLOW=10.**DLGFLW
        WIDTH=10.**DLGWTH
      END IF
C
      RETURN
      END
      SUBROUTINE SGWF1SFR1RDSEG(NLST,LSTBEG,IN,IOUT,SEG,ISEG,IDIVAR,
     1                  IOTSG,MAXPTS,XSEC,QSTAGE,I15,CONCQ,CONCRUN,
     2                  CONCPPT,NSOL,NSEGDIM,ISCHK,NISCHK,ICHK,NSS)
C
C
C     VERSION 1.4:CONNECTED TO LAK3 PACKAGE AND MODFLOW-GWT-- AUG. 2003
C     ******************************************************************
C     READ STREAM SEGMENT DATA -- parameters or non parameters
C
C     ******************************************************************
C
C     SPECIFICATIONS:
C     ------------------------------------------------------------------
      DIMENSION SEG(17,NSEGDIM),ISEG(3,NSEGDIM),IOTSG(NSEGDIM),
     1          IDIVAR(2,NSEGDIM),XSEC(16,NSEGDIM),
     2          QSTAGE(MAXPTS,NSEGDIM),ISCHK(NISCHK)
      DIMENSION CONCQ(NSEGDIM,NSOL),CONCRUN(NSEGDIM,NSOL),
     1          CONCPPT(NSEGDIM,NSOL)
C     ------------------------------------------------------------------
C
C8------READ STREAM SEGMENT DATA.
      IQSEG=LSTBEG
      LSTEND=LSTBEG+NLST-1
      DO WHILE (IQSEG.LE.LSTEND)
C
C9------ONLY READ FIRST 4 VARIABLES TO DETERMINE VALUE OF IUPSEG.
        READ(IN,*) N,ICALC,NOUTSEG,IUPSEG
        IF(N.GT.NSS .OR. N.LT.1) THEN
           WRITE(IOUT,1) N
    1      FORMAT(1X,/1X,'SEGMENT NUMBER (NSEG) OUT OF RANGE: ',I6)
           IF(ICHK.NE.0) THEN
             WRITE(IOUT,2) IQSEG-LSTBEG+1
    2        FORMAT(1X,'READING ENTRY ',I6,' OF ITEM 6A')
           ELSE
             WRITE(IOUT,3) IQSEG-LSTBEG+1
    3        FORMAT(1X,'READING ENTRY ',I6,' OF ITEM 4A')
           END IF
           CALL USTOP(' ')
        END IF
C
C10-----DETERMINE WHERE DATA ARE STORED
        IF(ICHK.NE.0) THEN
C  Store data in active segment area
           NSEG=N
           ISCHK(N)=ISCHK(N)+1
        ELSE
C  Store data in parameter area
           NSEG=IQSEG
           ISEG(3,IQSEG)=N
           SEG(1,NSEG)=SEG(1,N)
        END IF
        BACKSPACE IN
C
C11-----READ DATA SET 4A FOR SEGMENTS THAT ARE NOT DIVERSIONS.
        IF (IUPSEG.LE.0) THEN
          IF(ICALC.EQ.0) THEN
            READ(IN,*)IDUM,ISEG(1,NSEG),IOTSG(NSEG),
     1         IDIVAR(1,NSEG),(SEG(JJ,NSEG),JJ=2,5)
          ELSE IF (ICALC.EQ.1) THEN
            READ(IN,*)IDUM,ISEG(1,NSEG),IOTSG(NSEG),
     1         IDIVAR(1,NSEG),(SEG(JJ,NSEG),JJ=2,5),SEG(16,NSEG)
          ELSE IF (ICALC.EQ.2) THEN
            READ(IN,*)IDUM,ISEG(1,NSEG),IOTSG(NSEG),
     1         IDIVAR(1,NSEG),(SEG(JJ,NSEG),JJ=2,5),
     2         (SEG(JK,NSEG),JK=16,17)
          ELSE IF (ICALC.EQ.3) THEN
            READ(IN,*)IDUM,ISEG(1,NSEG),IOTSG(NSEG),
     1         IDIVAR(1,NSEG),(SEG(JJ,NSEG),JJ=2,5),SEG(9,NSEG),
     2         SEG(10,NSEG),SEG(14,NSEG),SEG(15,NSEG)
          ELSE IF (ICALC.EQ.4) THEN
            READ(IN,*)IDUM,ISEG(1,NSEG),IOTSG(NSEG),
     1         IDIVAR(1,NSEG),ISEG(2,NSEG),(SEG(JJ,NSEG),JJ=2,5)
          END IF
        ELSE
C
C12-----READ DATA 4A FOR SEGMENTS THAT ARE DIVERSIONS FROM STREAMS.
          IF(ICALC.LE.0) THEN
            READ(IN,*)IDUM,ISEG(1,NSEG),IOTSG(NSEG),
     1         (IDIVAR(II,NSEG),II=1,2),(SEG(JJ,NSEG),JJ=2,5)
          ELSE IF (ICALC.EQ.1) THEN
            READ(IN,*)IDUM,ISEG(1,NSEG),IOTSG(NSEG),
     1         (IDIVAR(II,NSEG),II=1,2),(SEG(JJ,NSEG),JJ=2,5),
     2         SEG(16,NSEG)
          ELSE IF (ICALC.EQ.2) THEN
            READ(IN,*)IDUM,ISEG(1,NSEG),IOTSG(NSEG),
     1         (IDIVAR(II,NSEG),II=1,2),(SEG(JJ,NSEG),JJ=2,5),
     2         (SEG(JK,NSEG),JK=16,17)
          ELSE IF (ICALC.EQ.3) THEN
            READ(IN,*)IDUM,ISEG(1,NSEG),IOTSG(NSEG),
     1         (IDIVAR(II,NSEG),II=1,2),(SEG(JJ,NSEG),JJ=2,5),
     2         SEG(9,NSEG),SEG(10,NSEG),SEG(14,NSEG),SEG(15,NSEG)
          ELSE IF (ICALC.EQ.4) THEN
            READ(IN,*)IDUM,ISEG(1,NSEG),IOTSG(NSEG),
     1         (IDIVAR(II,NSEG),II=1,2),ISEG(2,NSEG),
     2         (SEG(JJ,NSEG),JJ=2,5)
          END IF
        END IF
C
C13-----READ DATA SET 4B.
        IF (ICALC.LE.0) THEN
          READ(IN,*)(SEG(JJ,NSEG),JJ=6,10)
        ELSE IF (ICALC.EQ.1) THEN
          READ(IN,*)(SEG(JJ,NSEG),JJ=6,9)
        ELSE IF (ICALC.GE.2.AND.ICALC.LE.4) THEN
          READ(IN,*)(SEG(JJ,NSEG),JJ=6,8)
        END IF
C
C14-----READ DATA SET 4C.
        IF (ICALC.LE.0) THEN
          READ(IN,*)(SEG(JJ,NSEG),JJ=11,15)
        ELSE IF (ICALC.EQ.1) THEN
          READ(IN,*)(SEG(JJ,NSEG),JJ=11,14)
        ELSE IF (ICALC.GE.2.AND.ICALC.LE.4) THEN
          READ(IN,*)(SEG(JJ,NSEG),JJ=11,13)
        END IF
C
C15-----READ DATA SET 4D FOR SEGMENT WHEN ICALC IS 2.
        IF (ICALC.EQ.2) THEN
          READ(IN,*)(XSEC(JJ,NSEG),JJ=1,8)
          READ(IN,*)(XSEC(JJ,NSEG),JJ=9,16)
        END IF
C
C16-----READ DATA SET 4E FOR SEGMENT WHEN ICALC IS 4.
        IF (ICALC.EQ.4) THEN
          NSTRPTS=ISEG(2,NSEG)
          IF(NSTRPTS.LT.2) THEN
            WRITE(IOUT,6)N
    6       FORMAT(/1X,'NUMBER OF POINTS USED TO RELATE ',
     1          'STREAMFLOW WITH STREAM DEPTH AND WIDTH FOR ',
     2          'SEGMENT ',I6,' IS LESS THAN TWO'//1X,
     3          'PROGRAM STOPPING')
            CALL USTOP(' ')
          ELSE IF(NSTRPTS.GT.MAXPTS/3) THEN
            WRITE(IOUT,7)N,NSTRPTS
    7       FORMAT(/1X,'FOR SEGMENT ',I6,' NUMBER OF POINTS',
     1            'USED TO RELATE STREAMFLOW WITH DEPTH AND ',
     2            'WIDTH IS ',I5//1X,'WHICH IS MORE THAN ',
     3            'MAXIMUM NUMBER OF 50 POINTS',//1X,
     4            'PROGRAM STOPPING'//)
            CALL USTOP(' ')
          ELSE
            READ(IN,*)(QSTAGE(JJ,NSEG),JJ=1,NSTRPTS)
            READ(IN,*)(QSTAGE(JJ,NSEG),JJ=NSTRPTS+1,2*NSTRPTS)
            READ(IN,*)(QSTAGE(JJ,NSEG),JJ=2*NSTRPTS+1,3*NSTRPTS)
          END IF
        END IF
C
C17-----READ DATA SET 4F FOR SEGMENT IF SOLUTES SPECIFIED.
        IF (I15.GT.0) THEN
          ISOL=1
          DO WHILE (ISOL.LE.NSOL)
            IF(IDIVAR(1,NSEG).EQ.0) THEN
              READ(IN,*) CONCQ(NSEG,ISOL),CONCRUN(NSEG,ISOL),
     1                   CONCPPT(NSEG,ISOL)
            ELSE
              READ(IN,*) CONCRUN(NSEG,ISOL),CONCPPT(NSEG,ISOL)
            END IF
             ISOL=ISOL+1
          END DO
        END IF
C
        IQSEG=IQSEG+1
      END DO
C
      RETURN
      END
      SUBROUTINE SGWF1SFR1PARMOV(IN,IOUT,SEG,ISEG,IDIVAR,
     1          IOTSG,MAXPTS,XSEC,QSTAGE,I15,CONCQ,CONCRUN,
     2          CONCPPT,NSOL,NSEGDIM,NSEGCK,NSS)
C
C
C     VERSION 1.4:CONNECTED TO LAK3 PACKAGE AND MODFLOW-GWT-- AUG. 2003
C     ******************************************************************
C     MOVE STREAM PARAMETER DATA INTO ACTIVE SEGMENTS
C
C     ******************************************************************
C
C     SPECIFICATIONS:
C     ------------------------------------------------------------------
      INCLUDE 'param.inc'
      DIMENSION SEG(17,NSEGDIM),ISEG(3,NSEGDIM),IOTSG(NSEGDIM),
     1          IDIVAR(2,NSEGDIM),XSEC(16,NSEGDIM),
     2          QSTAGE(MAXPTS,NSEGDIM),NSEGCK(NSS)
      DIMENSION CONCQ(NSEGDIM,NSOL),CONCRUN(NSEGDIM,NSOL),
     1          CONCPPT(NSEGDIM,NSOL)
      CHARACTER*4 PACK
      CHARACTER*200 LINE
      CHARACTER*10 PNAME,CTMP3,CTMP4
C     ------------------------------------------------------------------
C
      PACK='SFR '
C1------READ PARAMETER NAME AND FIND IT IN THE PARAMETER LIST.
      READ(IN,'(A)') LINE
      LLOC=1
      CALL URWORD(LINE,LLOC,ISTART,ISTOP,0,IDUM,RDUM,IOUT,IN)
      PNAME=LINE(ISTART:ISTOP)
      WRITE(IOUT,1) PNAME
    1 FORMAT(/,' Parameter:  ',A)
      CALL UPARFIND(PNAME,'SFR','SFR',IP,IOUT)
C
C         DESIGNATE CELLS CORRESPONDING TO CORRECT PARAMETER INSTANCE
      NLST=IPLOC(2,IP)-IPLOC(1,IP)+1
      NUMINST=IPLOC(3,IP)
      ILOC=IPLOC(4,IP)
      NI=1
      IF(NUMINST.GT.0) THEN
        NLST=NLST/NUMINST
        CALL URWORD(LINE,LLOC,ISTART,ISTOP,0,IDUM,RDUM,IOUT,IN)
        CTMP3=LINE(ISTART:ISTOP)
        IF(CTMP3.EQ.' ') THEN
          WRITE(IOUT,1000)PACK,PARNAM(IP)
 1000     FORMAT(/,1X,'Blank instance name in the ',A,
     &           ' file for parameter ',A)
          CALL USTOP(' ')
        ENDIF
        WRITE(IOUT,1010) CTMP3
 1010   FORMAT(3X,'Instance:  ',A)
        CALL UPCASE(CTMP3)
        DO 50 KI=1,NUMINST
          CTMP4=INAME(ILOC+KI-1)
          CALL UPCASE(CTMP4)
          IF(CTMP3.EQ.CTMP4) THEN
            NI=KI
            GOTO 55
          ENDIF
   50   CONTINUE
        WRITE(IOUT,1020) PACK,CTMP3,PARNAM(IP)
 1020   FORMAT(/,1X,'The ',A,' file specifies undefined instance "',
     &         A,'" for parameter ',A)
        CALL USTOP(' ')
   55   CONTINUE
      ENDIF
C
      IF (IACTIVE(IP).GT.0) THEN
        WRITE(IOUT,1030) PARNAM(IP)
 1030   FORMAT(/,1X,'*** ERROR: PARAMETER "',A,
     &  '" HAS ALREADY BEEN ACTIVATED THIS STRESS PERIOD',/,
     &  ' -- STOP EXECUTION (SGWF1SFR1PARMOV)')
        CALL USTOP(' ')
      ENDIF
C
      IACTIVE(IP)=NI
C
C2------MOVE EACH ENTRY FOR THE PARAMETER
      IQSEG=IPLOC(1,IP)+(NI-1)*NLST
      LSTEND=IQSEG+NLST-1
      DO WHILE (IQSEG.LE.LSTEND)
C
C9------DETERMINE VALUES OF ICALC, NSEG, AND IUPSEG.
        ICALC=ISEG(1,IQSEG)
        NSEG=ISEG(3,IQSEG)
        IUPSEG=IDIVAR(1,IQSEG)
C
C10-----COUNT THE NUMBER OF TIMES A SEGMENT IS DEFINED.
        NSEGCK(NSEG)=NSEGCK(NSEG)+1
C
C11-----MOVE DATA SET 4A
        ISEG(1,NSEG)=ISEG(1,IQSEG)
        IOTSG(NSEG)=IOTSG(IQSEG)
        IDIVAR(1,NSEG)=IDIVAR(1,IQSEG)
        IF(IUPSEG.GT.0) IDIVAR(2,NSEG)=IDIVAR(2,IQSEG)
        SEG(2,NSEG)=SEG(2,IQSEG)
        SEG(3,NSEG)=SEG(3,IQSEG)
        SEG(4,NSEG)=SEG(4,IQSEG)
        SEG(5,NSEG)=SEG(5,IQSEG)
        IF (ICALC.EQ.1) THEN
          SEG(16,NSEG)=SEG(16,IQSEG)
        ELSE IF (ICALC.EQ.2) THEN
          SEG(16,NSEG)=SEG(16,IQSEG)
          SEG(17,NSEG)=SEG(17,IQSEG)
        ELSE IF (ICALC.EQ.3) THEN
          SEG(9,NSEG)=SEG(9,IQSEG)
          SEG(10,NSEG)=SEG(10,IQSEG)
          SEG(14,NSEG)=SEG(14,IQSEG)
          SEG(15,NSEG)=SEG(15,IQSEG)
        ELSE IF (ICALC.EQ.4) THEN
          ISEG(2,NSEG)=ISEG(2,IQSEG)
        END IF
C
C13-----MOVE DATA SET 4B.
        IF (ICALC.LE.0) THEN
          JEND=10
        ELSE IF (ICALC.EQ.1) THEN
          JEND=9
        ELSE IF (ICALC.GE.2.AND.ICALC.LE.4) THEN
          JEND=8
        END IF
        JJ=6
        DO WHILE (JJ.LE.JEND)
          SEG(JJ,NSEG)=SEG(JJ,IQSEG)
          JJ=JJ+1
        END DO
        SEG(6,NSEG)=SEG(6,NSEG)*B(IP)
C
C14-----MOVE DATA SET 4C.
        IF (ICALC.LE.0) THEN
          JEND=15
        ELSE IF (ICALC.EQ.1) THEN
          JEND=14
        ELSE IF (ICALC.GE.2.AND.ICALC.LE.4) THEN
          JEND=13
        END IF
        JJ=11
        DO WHILE (JJ.LE.JEND)
          SEG(JJ,NSEG)=SEG(JJ,IQSEG)
          JJ=JJ+1
        END DO
        SEG(11,NSEG)=SEG(11,NSEG)*B(IP)
C
C15-----MOVE DATA SET 4D FOR SEGMENT WHEN ICALC IS 2.
        IF (ICALC.EQ.2) THEN
          JJ=1
          DO WHILE (JJ.LE.16)
            XSEC(JJ,NSEG)=XSEC(JJ,IQSEG)
            JJ=JJ+1
          END DO
        END IF
C
C16-----MOVE DATA SET 4E FOR SEGMENT WHEN ICALC IS 4.
        IF (ICALC.EQ.4) THEN
          NSTRPTS=ISEG(2,NSEG)
          JJ=1
          DO WHILE (JJ .LE. NSTRPTS*3)
            QSTAGE(JJ,NSEG)=QSTAGE(JJ,IQSEG)
            JJ=JJ+1
          END DO
        END IF
C
C17-----MOVE DATA SET 4F FOR SEGMENT IF SOLUTES SPECIFIED.
        IF (I15.GT.0) THEN
          ISOL=1
          DO WHILE (ISOL.LE.NSOL)
            IF(IDIVAR(1,NSEG).EQ.0) THEN
              CONCQ(NSEG,ISOL)=CONCQ(IQSEG,ISOL)
              CONCRUN(NSEG,ISOL)=CONCRUN(IQSEG,ISOL)
              CONCPPT(NSEG,ISOL)=CONCPPT(IQSEG,ISOL)
            ELSE
              CONCRUN(NSEG,ISOL)=CONCRUN(IQSEG,ISOL)
              CONCPPT(NSEG,ISOL)=CONCPPT(IQSEG,ISOL)
            END IF
            ISOL=ISOL+1
          END DO
        END IF
C
        IQSEG=IQSEG+1
      END DO
C
      RETURN
      END
      SUBROUTINE SGWF1SFR1PRSEG(NLST,LSTBEG,IOUT,SEG,ISEG,IDIVAR,
     1                  IOTSG,MAXPTS,XSEC,QSTAGE,I15,CONCQ,CONCRUN,
     2                  CONCPPT,NSOL,NSEGDIM,IOUTS)
C
C
C     VERSION 1.4:CONNECTED TO LAK3 PACKAGE AND MODFLOW-GWT-- AUG. 2003
C     ******************************************************************
C     PRINT STREAM SEGMENT DATA -- parameters or non parameters
C
C     ******************************************************************
C
C     SPECIFICATIONS:
C     ------------------------------------------------------------------
      DIMENSION SEG(17,NSEGDIM),ISEG(3,NSEGDIM),IOTSG(NSEGDIM),
     1          IDIVAR(2,NSEGDIM),XSEC(16,NSEGDIM),
     2          QSTAGE(MAXPTS,NSEGDIM)
      DIMENSION CONCQ(NSEGDIM,NSOL),CONCRUN(NSEGDIM,NSOL),
     1          CONCPPT(NSEGDIM,NSOL)
C     ------------------------------------------------------------------
C
      LSTEND=NLST+LSTBEG-1
      WRITE(IOUT,17)
   17 FORMAT(1X,//20X,'INPUT DATA FOR EACH STREAM SEGMENT',
     1            /1X,93('-')/)
C
C27-----PRINT INPUT FLOW RATES FOR EACH STREAM SEGMENT.
      WRITE(IOUT,18)
   18 FORMAT(1X,'SEGMENT    SEG.     INFLOW   OVERLAND   ',
     1        'STREAM    STREAM   ICALC  OUTFLOW  DIVERSION PRIORITY',
     2        /4X,'NO.    LENGTH     RATE     RUNOFF      ',
     3        'ET       PPT.    METH.  TO SEG.  FROM SEG.    NO.'/)
      NSEG=LSTBEG
      DO WHILE (NSEG.LE.LSTEND)
        IF(LSTBEG.EQ.1) THEN
          NN=NSEG
        ELSE
          NN=ISEG(3,NSEG)
        END IF
        WRITE(IOUT,19)NN,(SEG(II,NSEG),II=1,5),ISEG(1,NSEG),
     1                        IOTSG(NSEG),(IDIVAR(JJ,NSEG),JJ=1,2)
   19   FORMAT(1X,I6,1X,1P5E10.3,2X,I3,3X,I6,3X,I6,4X,I5)
        NSEG=NSEG+1
      END DO
C
C28-----PRINT STREAMBED PROPERTIES AND STREAM DIMENSIONS.
      IF(LSTBEG.EQ.1) THEN
        WRITE(IOUT,20)
   20   FORMAT (1X,//9X,'STREAMBED PROPERTIES AND STREAM ',
     1        'DIMENSIONS',//1X,'SEGMENT     BED HYD. COND.',6X,
     2        'BED THICKNESS     ELEV.-TOP OF BED     WIDTH OF ',
     3        'STREAM     DEPTH OF STREAM    STREAM ROUGHNESS',/1X,
     4        '   No.     UPPER     LOWER     UPPER     ',
     5        'LOWER     UPPER     LOWER     UPPER     LOWER     ',
     6        'UPPER     LOWER   CHANNEL      BANK'/)
      ELSE
        WRITE(IOUT,210)
  210   FORMAT (1X,//9X,'STREAMBED PROPERTIES AND STREAM ',
     1        'DIMENSIONS',//1X,'SEGMENT  BED HYD. COND. FACTOR',2X,
     2        'BED THICKNESS     ELEV.-TOP OF BED     WIDTH OF ',
     3        'STREAM     DEPTH OF STREAM    STREAM ROUGHNESS',/1X,
     4        '   No.     UPPER     LOWER     UPPER     ',
     5        'LOWER     UPPER     LOWER     UPPER     LOWER     ',
     6        'UPPER     LOWER   CHANNEL      BANK'/)
      END IF
      NSEG=LSTBEG
      DO WHILE (NSEG.LE.LSTEND)
        IF(LSTBEG.EQ.1) THEN
          NN=NSEG
        ELSE
          NN=ISEG(3,NSEG)
        END IF
        ICALC=ISEG(1,NSEG)
        IF(ICALC.EQ.0) THEN
          WRITE(IOUT,21)NN,SEG(6,NSEG),SEG(11,NSEG),
     1                    SEG(7,NSEG),SEG(12,NSEG),SEG(8,NSEG),
     2                    SEG(13,NSEG),SEG(9,NSEG),SEG(14,NSEG),
     3                    SEG(10,NSEG),SEG(15,NSEG)
   21     FORMAT(I6,1X,1P10E10.3)
        ELSE IF (ICALC.EQ.1) THEN
          WRITE(IOUT,22)NN,SEG(6,NSEG),SEG(11,NSEG),
     1                    SEG(7,NSEG),SEG(12,NSEG),SEG(8,NSEG),
     2                    SEG(13,NSEG),SEG(9,NSEG),SEG(14,NSEG),
     3                    SEG(16,NSEG)
   22     FORMAT(I6,1X,1P8E10.3,20X,1PE10.3)
        ELSE IF (ICALC.EQ.2) THEN
          WRITE(IOUT,23)NN,SEG(6,NSEG),SEG(11,NSEG),
     1                    SEG(7,NSEG),SEG(12,NSEG),SEG(8,NSEG),
     2                    SEG(13,NSEG),SEG(16,NSEG),SEG(17,NSEG)
   23     FORMAT(I6,1X,1P6E10.3,40X,1P2E10.3)
        ELSE IF (ICALC.GE.3) THEN
          WRITE(IOUT,24)NN,SEG(6,NSEG),SEG(11,NSEG),
     1                    SEG(7,NSEG),SEG(12,NSEG),SEG(8,NSEG),
     2                    SEG(13,NSEG)
   24     FORMAT(I6,1X,1P6E10.3)
        END IF
        NSEG=NSEG+1
      END DO
C
C29-----PRINT CROSS SECTIONAL DATA FOR SEGMENTS WITH ICALC=2.
      NSEG=LSTBEG
      IFLG=0
      DO WHILE (NSEG.LE.LSTEND)
        IF(LSTBEG.EQ.1) THEN
          NN=NSEG
        ELSE
          NN=ISEG(3,NSEG)
        END IF
        ICALC=ISEG(1,NSEG)
        IF(ICALC.EQ.2.AND.IFLG.EQ.0) THEN
          WRITE(IOUT,25)
   25     FORMAT(1X,/1X,' EIGHT POINT CROSS SECTION DATA ',
     1               'FOR SEGMENTS WITH ICALC = 2',/3X,' X VALUES',
     2               ' X VALUES START FROM LEFT SIDE LOOKING ',
     3               'DOWNSTREAM',//5X,'SEGMENT NO.',
     4               '        X1        X2        X3        X4',
     5               '        X5        X6        X7        X8')
          IFLG=1
        END IF
        IF(ICALC.EQ.2.AND.IFLG.EQ.1) THEN
          WRITE(IOUT,26)NN,(XSEC(I,NSEG),I=1,8)
   26     FORMAT(7X,I6,5X,8(1PE10.3))
        END IF
        NSEG=NSEG+1
      END DO
      NSEG=LSTBEG
      IFLG=0
      DO WHILE (NSEG.LE.LSTEND)
        IF(LSTBEG.EQ.1) THEN
          NN=NSEG
        ELSE
          NN=ISEG(3,NSEG)
        END IF
        ICALC=ISEG(1,NSEG)
        IF(ICALC.EQ.2.AND.IFLG.EQ.0) THEN
          WRITE(IOUT,27)
   27     FORMAT(1X,/3X,' Z VALUES ARE RELATIVE TO STREAM',
     1                  'BED ELEVATION',//5X,'SEGMENT NO.          ',
     2                  'Z1        Z2        Z3        Z4        Z5',
     3                  '        Z6        Z7        Z8')
          IFLG=1
        END IF
        IF (ICALC.EQ.2.AND.IFLG.EQ.1) THEN
          WRITE(IOUT,28)NN,(XSEC(I,NSEG),I=9,16)
   28     FORMAT(7X,I6,5X,8(1PE10.3))
        END IF
        NSEG=NSEG+1
      END DO
C
C30-----PRINT STREAMFLOW, DEPTH AND WIDTH RELATIONS FOR SEGMENTS
C        WITH ICALC=3.
      NSEG=LSTBEG
      IFLG=0
      DO WHILE (NSEG.LE.LSTEND)
        IF(LSTBEG.EQ.1) THEN
          NN=NSEG
        ELSE
          NN=ISEG(3,NSEG)
        END IF
        ICALC=ISEG(1,NSEG)
        IF(ICALC.EQ.3.AND.IFLG.EQ.0) THEN
          WRITE(IOUT,29)
   29     FORMAT(/1X,'STREAMFLOW RELATION WITH DEPTH IS ',
     1            'BASED ON EQUATION Q = CDPTH*(DEPTH)**FDPTH',
     2            /1X,'STREAMFLOW RELATION WITH WIDTH IS ',
     3            'BASED ON EQUATION Q = AWDTH*(WIDTH)**BWDTH',
     4            //1X,'SEGMENT NO.      CDPTH     FDPTH    ',
     5            'AWDTH     BWDTH'/)
          IFLG=1
        END IF
        IF(ICALC.EQ.3.AND.IFLG.EQ.1) THEN
          WRITE(IOUT,30)NN,SEG(9,NSEG),SEG(10,NSEG),
     1                        SEG(14,NSEG),SEG(15,NSEG)
   30      FORMAT(5X,I6,1P4E10.3)
        END IF
        NSEG=NSEG+1
      END DO
C
C31-----PRINT TABULATED VALUES FOR COMPUTING STREAM WIDTH AND DEPTH
C         FROM STREAMFLOW FOR SEGMENTS WITH ICALC=4.
      NSEG=LSTBEG
      IFLG=0
      DO WHILE (NSEG.LE.LSTEND)
        IF(LSTBEG.EQ.1) THEN
          NN=NSEG
        ELSE
          NN=ISEG(3,NSEG)
        END IF
        ICALC=ISEG(1,NSEG)
        NSTRPTS=ISEG(2,NSEG)
        IF(ICALC.EQ.4.AND.IFLG.EQ.0) THEN
           WRITE(IOUT,33)
   33      FORMAT(1X,/1X,'STREAMFLOW RELATION WITH DEPTH ',
     1              'AND WIDTH IS BASED ON TABULATED VALUES',//2X,
     2              'SEGMENT NO.   STREAMFLOW       DEPTH       ',
     3              'WIDTH',/)
           IFLG=1
        END IF
        IPT=1
        IF(ICALC.EQ.4.AND.IFLG.EQ.1) THEN
          DO WHILE(IPT.LE.NSTRPTS)
            WRITE(IOUT,34)NN,QSTAGE(IPT,NSEG),
     1                  QSTAGE(NSTRPTS+IPT,NSEG),
     2                  QSTAGE(2*NSTRPTS+IPT,NSEG)
   34       FORMAT(5X,I6,2X,3(3X,1PE10.4))
            IPT=IPT+1
          END DO
        END IF
        NSEG=NSEG+1
      END DO
C
C32-----PRINT SOLUTE DATA FOR EACH STREAM SEGMENT.
      IF(I15.GT.0) THEN
        ISOL=1
        DO WHILE(ISOL.LE.NSOL)
          WRITE(IOUTS,35)ISOL
   35     FORMAT(1X,//10X,' DATA FOR EACH STREAM SEGMENT:',
     1                ' SOLUTE No. ',I2//5X,'SEGMENT          ',
     2                'SOLUTE CONCENTRATION IN:    ',/5X,
     3                'NUMBER       SEGMENT INFLOW   OVERLAND FLOW',
     4                3X,'PRECIPITATION')
          NSEG=LSTBEG
          DO WHILE(NSEG.LE.LSTEND)
            IF(LSTBEG.EQ.1) THEN
              NN=NSEG
            ELSE
              NN=ISEG(3,NSEG)
            END IF
cgzh change to output
            IF(IDIVAR(1,NSEG).EQ.0) THEN
              WRITE(IOUTS,36)NN,CONCQ(NSEG,ISOL),
     1                      CONCRUN(NSEG,ISOL),CONCPPT(NSEG,ISOL)
            ELSE
              WRITE(IOUTS,37)NN,
     1                      CONCRUN(NSEG,ISOL),CONCPPT(NSEG,ISOL)
            END IF
   36       FORMAT(1X,/4X,I6,9X,1PE10.3,6X,E10.3,6X,E10.3)
   37       FORMAT(1X,/4X,I6,9X,'   N/A    ',6X,E10.3,6X,E10.3)
            NSEG=NSEG+1
          END DO
          ISOL=ISOL+1
        END DO
        WRITE (IOUTS,3)
    3   FORMAT(//)
      END IF
C
      RETURN
      END
C
C-----SUBROUTINE GWF1SFR1SEN written by erb, february 10, 2004
C
      SUBROUTINE GWF1SFR1SEN(IOUTG,NPLIST,NSEGDIM,ISEG,ISENS)
C     ******************************************************************
Cerb  Check for incompatibilities with the SEN Process.
Cerb  Currently(Feb. 2004), the SFR Package is incompatible with the
Cerb  Sensitivity Process when ICALC has values other than 0 or 1.
Cerb  If input does not comply with this restriction, write a message
Cerb  and STOP.  Also, stop if ISENS>0 for an SFR parameter.
C     ******************************************************************
C
C     SPECIFICATIONS:
C     ------------------------------------------------------------------
      IMPLICIT NONE
      INTEGER I, IERR, IOUTG, NPLIST, NSEGDIM
      INTEGER ISEG(3,NSEGDIM), ISENS(NPLIST)
      INCLUDE 'param.inc'
C
  100 FORMAT(/,1X,
     &'ERROR: The current version of the SFR Package is ',
     &'incompatible with the',/,
     &' Sensitivity Process when ICALC for any segment has a value',
     &' other than 0 or 1',/,
     &' -- STOP EXECUTION (GWF1SFR1SEN)')
  120 FORMAT(/,1X,
     &'ERROR: The current version of MODFLOW-2000 does not',
     &' support calculation of',/,
     &' sensitivities for parameters defined in the SFR Package',/,
     &' -- STOP EXECUTION (GWF1SFR1SEN)')
C
C     Check for ICALC values > 1
      IERR = 0
      DO I=1,NSEGDIM
        IF (ISEG(1,I).GT.1) THEN
          WRITE(IOUTG,100)
          IERR = IERR+1
          GOTO 10
        ENDIF
      ENDDO
   10 CONTINUE
C
C     Ensure that sensitivities are not to be calculated for any SFR
C     parameter
      DO I=1,NPLIST
        IF (PARTYP(I) .EQ. 'SFR') THEN
          IF (ISENS(I).GT.0) THEN
            WRITE(IOUTG,120)
            IERR = IERR+1
            GOTO 20
          ENDIF
        ENDIF
      ENDDO
   20 CONTINUE
C
      IF (IERR>0) CALL USTOP(' ')
      RETURN
      END
